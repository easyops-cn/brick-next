{"version":3,"file":"chunks/5151.07ac19f2.js","mappings":"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","sources":["webpack:///../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack:///../../node_modules/@next-core/cook/dist/esm/ExecutionContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/traverse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/context-free.js","webpack:///../../node_modules/@next-core/cook/dist/esm/sanitize.js","webpack:///../../node_modules/@next-core/cook/dist/esm/cook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/AnalysisContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/hasOwnProperty.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precookFunction.js","webpack:///../../node_modules/@next-core/cook/dist/esm/parse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/preevaluate.js"],"sourcesContent":["import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nexport default function _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class ExecutionContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n    _defineProperty(this, \"Function\", void 0);\n  }\n}\n// https://tc39.es/ecma262/#sec-environment-records\nexport class EnvironmentRecord {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingMap\", new Map());\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingMap.has(name);\n  }\n  CreateMutableBinding(name, deletable) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      mutable: true,\n      deletable\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Create an immutable binding.\n   *\n   * @param name - The binding name.\n   * @param strict - For named function expressions, strict is false, otherwise it's true.\n   * @returns CompletionRecord.\n   */\n  CreateImmutableBinding(name, strict) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      strict\n    });\n    return NormalCompletion(undefined);\n  }\n  InitializeBinding(name, value) {\n    var binding = this.bindingMap.get(name);\n    // Assert: binding exists and uninitialized.\n    Object.assign(binding, {\n      initialized: true,\n      value\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Update a mutable binding value, including function declarations.\n   *\n   * @param name - The binding name.\n   * @param value - The binding value.\n   * @param strict - For functions, strict is always false, otherwise it depends on strict-mode.\n   * @returns\n   */\n  SetMutableBinding(name, value, strict) {\n    var binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(\"\".concat(name, \" is not initialized\"));\n    } else if (binding.mutable) {\n      binding.value = value;\n    } else {\n      throw new TypeError(\"Assignment to constant variable\");\n    }\n    return NormalCompletion(undefined);\n  }\n  GetBindingValue(name, strict) {\n    var binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(\"\".concat(name, \" is not initialized\"));\n    }\n    return binding.value;\n  }\n}\nexport class DeclarativeEnvironment extends EnvironmentRecord {}\nexport class FunctionEnvironment extends EnvironmentRecord {}\nexport var SourceNode = Symbol.for(\"SourceNode\");\nexport var FormalParameters = Symbol.for(\"FormalParameters\");\nexport var ECMAScriptCode = Symbol.for(\"ECMAScriptCode\");\nexport var Environment = Symbol.for(\"Environment\");\nexport var IsConstructor = Symbol.for(\"IsConstructor\");\n// https://tc39.es/ecma262/#sec-reference-record-specification-type\nexport class ReferenceRecord {\n  constructor(base, referenceName, strict) {\n    _defineProperty(this, \"Base\", void 0);\n    _defineProperty(this, \"ReferenceName\", void 0);\n    /** Whether the reference is in strict mode. */\n    _defineProperty(this, \"Strict\", void 0);\n    this.Base = base;\n    this.ReferenceName = referenceName;\n    this.Strict = strict;\n  }\n}\n\n// https://tc39.es/ecma262/#sec-completion-record-specification-type\nexport class CompletionRecord {\n  constructor(type, value) {\n    _defineProperty(this, \"Type\", void 0);\n    _defineProperty(this, \"Value\", void 0);\n    this.Type = type;\n    this.Value = value;\n  }\n}\n// https://tc39.es/ecma262/#sec-normalcompletion\nexport function NormalCompletion(value) {\n  return new CompletionRecord(\"normal\", value);\n}\nexport var Empty = Symbol(\"empty completion\");\n//# sourceMappingURL=ExecutionContext.js.map","export function collectBoundNames(root) {\n  var names = new Set();\n  var collect = node => {\n    if (Array.isArray(node)) {\n      for (var n of node) {\n        collect(n);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"Identifier\":\n          names.add(node.name);\n          return;\n        case \"VariableDeclaration\":\n          return collect(node.declarations);\n        case \"VariableDeclarator\":\n          return collect(node.id);\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return collect(node.left);\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n        case \"FunctionDeclaration\":\n          return collect(node.id);\n      }\n    }\n  };\n  collect(root);\n  return Array.from(names);\n}\nexport function containsExpression(root) {\n  var collect = node => {\n    if (Array.isArray(node)) {\n      return node.some(collect);\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return true;\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return node.computed || collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n      }\n    }\n  };\n  return collect(root);\n}\nexport function collectScopedDeclarations(root, options) {\n  var declarations = [];\n  var nextOptions = {\n    var: options.var\n  };\n  var collect = (node, options) => {\n    if (Array.isArray(node)) {\n      for (var n of node) {\n        collect(n, options);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"FunctionDeclaration\":\n          // At the top level of a function, or script, function declarations are\n          // treated like var declarations rather than like lexical declarations.\n          // See https://tc39.es/ecma262/#sec-static-semantics-toplevellexicallydeclarednames\n          if (Number(!options.var) ^ Number(options.topLevel)) {\n            declarations.push(node);\n          }\n          return;\n        case \"VariableDeclaration\":\n          if (Number(!options.var) ^ Number(node.kind === \"var\")) {\n            declarations.push(node);\n          }\n          return;\n        case \"SwitchCase\":\n          collect(node.consequent, nextOptions);\n          return;\n        case \"CatchClause\":\n          collect(node.body, nextOptions);\n          return;\n      }\n      if (options.var) {\n        switch (node.type) {\n          case \"BlockStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"IfStatement\":\n            collect(node.consequent, nextOptions);\n            collect(node.alternate, nextOptions);\n            return;\n          case \"DoWhileStatement\":\n          case \"WhileStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"ForStatement\":\n            collect(node.init, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            collect(node.left, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"SwitchStatement\":\n            collect(node.cases, nextOptions);\n            return;\n          case \"TryStatement\":\n            collect(node.block, nextOptions);\n            collect(node.handler, nextOptions);\n            collect(node.finalizer, nextOptions);\n            return;\n        }\n      }\n    }\n  };\n  collect(root, options);\n  return declarations;\n}\n//# sourceMappingURL=traverse.js.map","import { CompletionRecord, Empty, EnvironmentRecord, NormalCompletion, ReferenceRecord } from \"./ExecutionContext.js\";\nimport { collectBoundNames } from \"./traverse.js\";\n\n// https://tc39.es/ecma262/#sec-ispropertyreference\nexport function IsPropertyReference(V) {\n  return V.Base !== \"unresolvable\" && !(V.Base instanceof EnvironmentRecord);\n}\n\n// https://tc39.es/ecma262/#sec-initializereferencedbinding\nexport function InitializeReferencedBinding(V, W) {\n  var base = V.Base;\n  return base.InitializeBinding(V.ReferenceName, W);\n}\n\n// https://tc39.es/ecma262/#sec-copydataproperties\nexport function CopyDataProperties(target, source, excludedItems) {\n  if (source === undefined || source === null) {\n    return target;\n  }\n  var keys = Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source));\n  for (var nextKey of keys) {\n    if (!excludedItems.has(nextKey)) {\n      var desc = Object.getOwnPropertyDescriptor(source, nextKey);\n      if (desc !== null && desc !== void 0 && desc.enumerable) {\n        target[nextKey] = source[nextKey];\n      }\n    }\n  }\n  return target;\n}\n\n// https://tc39.es/ecma262/#sec-runtime-semantics-fordeclarationbindinginstantiation\nexport function ForDeclarationBindingInstantiation(forDeclaration, env) {\n  var isConst = forDeclaration.kind === \"const\";\n  for (var name of collectBoundNames(forDeclaration)) {\n    if (isConst) {\n      env.CreateImmutableBinding(name, true);\n    } else {\n      env.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// https://tc39.es/ecma262/#sec-loopcontinues\nexport function LoopContinues(completion) {\n  return completion.Type === \"normal\" || completion.Type == \"continue\";\n}\n\n// https://tc39.es/ecma262/#sec-updateempty\nexport function UpdateEmpty(completion, value) {\n  if (completion.Value !== Empty) {\n    return completion;\n  }\n  return new CompletionRecord(completion.Type, value);\n}\n\n// https://tc39.es/ecma262/#sec-getvalue\nexport function GetValue(V) {\n  if (V instanceof CompletionRecord) {\n    // Assert: V.Type is normal.\n    V = V.Value;\n  }\n  if (!(V instanceof ReferenceRecord)) {\n    return V;\n  }\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(\"\".concat(V.ReferenceName, \" is not defined\"));\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    var base = V.Base;\n    return base.GetBindingValue(V.ReferenceName, V.Strict);\n  }\n  return V.Base[V.ReferenceName];\n}\n\n// https://tc39.es/ecma262/#sec-topropertykey\nexport function ToPropertyKey(arg) {\n  if (typeof arg === \"symbol\") {\n    return arg;\n  }\n  return String(arg);\n}\n\n// https://tc39.es/ecma262/#sec-getv\nexport function GetV(V, P) {\n  return V[P];\n}\n\n// https://tc39.es/ecma262/#sec-putvalue\nexport function PutValue(V, W) {\n  // Assert: V is a ReferenceRecord.\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(\"\".concat(V.ReferenceName, \" is not defined\"));\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    return V.Base.SetMutableBinding(V.ReferenceName, W, V.Strict);\n  }\n  V.Base[V.ReferenceName] = W;\n  return NormalCompletion(undefined);\n}\n\n// https://tc39.es/ecma262/#sec-createlistiteratorRecord\nexport function CreateListIteratorRecord(args) {\n  if (!isIterable(args)) {\n    throw new TypeError(\"\".concat(typeof args, \" is not iterable\"));\n  }\n  return args[Symbol.iterator]();\n}\n\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nexport function RequireObjectCoercible(arg) {\n  if (arg === null || arg === undefined) {\n    throw new TypeError(\"Cannot destructure properties of undefined or null\");\n  }\n}\n\n// https://tc39.es/ecma262/#sec-getidentifierreference\nexport function GetIdentifierReference(env, name, strict) {\n  if (!env) {\n    return new ReferenceRecord(\"unresolvable\", name, strict);\n  }\n  if (env.HasBinding(name)) {\n    return new ReferenceRecord(env, name, strict);\n  }\n  return GetIdentifierReference(env.OuterEnv, name, strict);\n}\n\n// https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator\nexport function ApplyStringOrNumericBinaryOperator(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+\":\n      return leftValue + rightValue;\n    case \"-\":\n      return leftValue - rightValue;\n    case \"/\":\n      return leftValue / rightValue;\n    case \"%\":\n      return leftValue % rightValue;\n    case \"*\":\n      return leftValue * rightValue;\n    case \"**\":\n      return leftValue ** rightValue;\n    case \"==\":\n      return leftValue == rightValue;\n    case \"===\":\n      return leftValue === rightValue;\n    case \"!=\":\n      return leftValue != rightValue;\n    case \"!==\":\n      return leftValue !== rightValue;\n    case \">\":\n      return leftValue > rightValue;\n    case \"<\":\n      return leftValue < rightValue;\n    case \">=\":\n      return leftValue >= rightValue;\n    case \"<=\":\n      return leftValue <= rightValue;\n  }\n  throw new SyntaxError(\"Unsupported binary operator `\".concat(operator, \"`\"));\n}\n\n// https://tc39.es/ecma262/#sec-assignment-operators\nexport function ApplyStringOrNumericAssignment(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+=\":\n    case \"-=\":\n    case \"*=\":\n    case \"/=\":\n    case \"%=\":\n    case \"**=\":\n      return ApplyStringOrNumericBinaryOperator(leftValue, operator.substr(0, operator.length - 1), rightValue);\n  }\n  throw new SyntaxError(\"Unsupported assignment operator `\".concat(operator, \"`\"));\n}\n\n// https://tc39.es/ecma262/#sec-unary-operators\nexport function ApplyUnaryOperator(target, operator) {\n  switch (operator) {\n    case \"!\":\n      return !target;\n    case \"+\":\n      return +target;\n    case \"-\":\n      return -target;\n    case \"void\":\n      return undefined;\n  }\n  throw new SyntaxError(\"Unsupported unary operator `\".concat(operator, \"`\"));\n}\nexport function isIterable(cooked) {\n  if (Array.isArray(cooked)) {\n    return true;\n  }\n  if (cooked === null || cooked === undefined) {\n    return false;\n  }\n  return typeof cooked[Symbol.iterator] === \"function\";\n}\n//# sourceMappingURL=context-free.js.map","// Ref https://github.com/tc39/proposal-global\n// In addition, the es6-shim had to switch from Function('return this')()\n// due to CSP concerns, such that the current check to handle browsers,\n// node, web workers, and frames is:\n// istanbul ignore next\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getGlobal() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}\n\n/**\n * There are chances to construct a `Function` from a string, etc.\n * ```\n * ((a,b)=>a[b])(()=>1, 'constructor')('console.log(`yo`)')()\n * ```\n */\nvar reservedObjects = new WeakSet([\n// `Function(\"...\")` is considered *extremely vulnerable*.\nFunction,\n// `Object.assign()` is considered vulnerable.\nObject,\n// `prototype` is considered vulnerable.\nFunction.prototype, Object.prototype,\n// Global `window` is considered vulnerable, too.\ngetGlobal()]);\nexport function sanitize(cooked) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  if (reservedObjects.has(cooked)) {\n    throw new TypeError(\"Cannot access reserved objects such as `Function`.\");\n  }\n}\nvar allowedConstructors = new WeakSet([Array, Map, Set, URLSearchParams, WeakMap, WeakSet, RegExp]);\nexport function isAllowedConstructor(constructor) {\n  // `Date` maybe mocked when running tests for storyboard functions.\n  return allowedConstructors.has(constructor) || constructor === Date;\n}\n//# sourceMappingURL=sanitize.js.map","import { ApplyStringOrNumericAssignment, CreateListIteratorRecord, ApplyStringOrNumericBinaryOperator, GetV, GetValue, InitializeReferencedBinding, IsPropertyReference, LoopContinues, PutValue, RequireObjectCoercible, ToPropertyKey, UpdateEmpty, ApplyUnaryOperator, GetIdentifierReference, ForDeclarationBindingInstantiation, CopyDataProperties } from \"./context-free.js\";\nimport { CompletionRecord, DeclarativeEnvironment, ECMAScriptCode, Empty, Environment, ExecutionContext, FormalParameters, FunctionEnvironment, IsConstructor, NormalCompletion, ReferenceRecord, SourceNode } from \"./ExecutionContext.js\";\nimport { sanitize, isAllowedConstructor } from \"./sanitize.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\n/** For next-core internal usage only. */\nexport function cook(rootAst, codeSource) {\n  var _hooks$beforeEvaluate3;\n  var {\n    rules,\n    globalVariables = {},\n    hooks = {}\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var expressionOnly = rootAst.type !== \"FunctionDeclaration\";\n  var rootEnv = new DeclarativeEnvironment(null);\n  var rootContext = new ExecutionContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  var executionContextStack = [rootContext];\n  for (var [key, value] of Object.entries(globalVariables)) {\n    rootEnv.CreateImmutableBinding(key, true);\n    rootEnv.InitializeBinding(key, value);\n  }\n  var TemplateMap = new WeakMap();\n\n  // https://tc39.es/ecma262/#sec-gettemplateobject\n  function GetTemplateObject(templateLiteral) {\n    var memo = TemplateMap.get(templateLiteral);\n    if (memo) {\n      return memo;\n    }\n    var rawObj = templateLiteral.quasis.map(quasi => quasi.value.raw);\n    var template = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n    Object.freeze(rawObj);\n    Object.defineProperty(template, \"raw\", {\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.freeze(template);\n    TemplateMap.set(templateLiteral, template);\n    return template;\n  }\n  function Evaluate(node, optionalChainRef) {\n    var _hooks$beforeEvaluate, _hooks$beforeBranch, _hooks$beforeBranch2;\n    (_hooks$beforeEvaluate = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate === void 0 || _hooks$beforeEvaluate.call(hooks, node);\n    // Expressions:\n    switch (node.type) {\n      case \"ArrayExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-array-initializer\n          var array = [];\n          for (var element of node.elements) {\n            if (!element) {\n              array.length += 1;\n            } else if (element.type === \"SpreadElement\") {\n              var spreadValues = GetValue(Evaluate(element.argument));\n              array.push(...spreadValues);\n            } else {\n              array.push(GetValue(Evaluate(element)));\n            }\n          }\n          return NormalCompletion(array);\n        }\n      case \"ArrowFunctionExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-arrow-function-definitions\n          ThrowIfFunctionIsInvalid(node);\n          var closure = InstantiateArrowFunctionExpression(node);\n          return NormalCompletion(closure);\n        }\n      case \"BinaryExpression\":\n        {\n          var leftRef = Evaluate(node.left);\n          var leftValue = GetValue(leftRef);\n          var rightRef = Evaluate(node.right).Value;\n          var rightValue = GetValue(rightRef);\n          if (expressionOnly && node.operator === \"|>\") {\n            // Minimal pipeline operator is supported only in expression-only mode.\n            // See https://tc39.es/proposal-pipeline-operator\n            // and https://github.com/tc39/proposal-pipeline-operator\n            if (typeof rightValue !== \"function\") {\n              var funcName = codeSource.substring(node.right.start, node.right.end);\n              throw new TypeError(\"\".concat(funcName, \" is not a function\"));\n            }\n            var thisValue;\n            if (rightRef instanceof ReferenceRecord) {\n              if (IsPropertyReference(rightRef)) {\n                thisValue = rightRef.Base;\n              }\n            }\n            return NormalCompletion(rightValue.call(thisValue, leftValue));\n          }\n          // https://tc39.es/ecma262/#sec-additive-operators\n          var result = ApplyStringOrNumericBinaryOperator(leftValue, node.operator, rightValue);\n          return NormalCompletion(result);\n        }\n      case \"CallExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-function-calls\n          var ref = Evaluate(node.callee, optionalChainRef).Value;\n          var func = GetValue(ref);\n          if ((func === undefined || func === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          sanitize(func);\n          return EvaluateCall(func, ref, node.arguments, node.callee);\n        }\n      case \"ChainExpression\":\n        // https://tc39.es/ecma262/#sec-optional-chains\n        return Evaluate(node.expression, {});\n      case \"ConditionalExpression\":\n        // https://tc39.es/ecma262/#sec-conditional-operator\n        return NormalCompletion(GetValue(Evaluate(GetValue(Evaluate(node.test)) ? node.consequent : node.alternate)));\n      case \"Identifier\":\n        // https://tc39.es/ecma262/#sec-identifiers\n        return NormalCompletion(ResolveBinding(node.name));\n      case \"Literal\":\n        {\n          // https://tc39.es/ecma262/#sec-primary-expression-literals\n          if (node.regex) {\n            if (node.value === null) {\n              // Invalid regular expression fails silently in @babel/parser.\n              throw new SyntaxError(\"Invalid regular expression: \".concat(node.raw));\n            }\n            if (node.regex.flags.includes(\"u\")) {\n              // Currently unicode flag is not fully supported across major browsers.\n              throw new SyntaxError(\"Unsupported unicode flag in regular expression: \".concat(node.raw));\n            }\n          }\n          return NormalCompletion(node.value);\n        }\n      case \"LogicalExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-binary-logical-operators\n          var _leftValue = GetValue(Evaluate(node.left));\n          switch (node.operator) {\n            case \"&&\":\n              return NormalCompletion(_leftValue && GetValue(Evaluate(node.right)));\n            case \"||\":\n              return NormalCompletion(_leftValue || GetValue(Evaluate(node.right)));\n            case \"??\":\n              return NormalCompletion(_leftValue !== null && _leftValue !== void 0 ? _leftValue : GetValue(Evaluate(node.right)));\n            // istanbul ignore next\n            default:\n              throw new SyntaxError( // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore never reach here.\n              \"Unsupported logical operator '\".concat(node.operator, \"'\"));\n          }\n        }\n      case \"MemberExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-property-accessors\n          var baseReference = Evaluate(node.object, optionalChainRef).Value;\n          var baseValue = GetValue(baseReference);\n          if ((baseValue === undefined || baseValue === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          sanitize(baseValue);\n          var _result = node.computed ? EvaluatePropertyAccessWithExpressionKey(baseValue, node.property, true) : EvaluatePropertyAccessWithIdentifierKey(baseValue, node.property, true);\n          sanitize(_result);\n          return NormalCompletion(_result);\n        }\n      case \"NewExpression\":\n        // https://tc39.es/ecma262/#sec-new-operator\n        return EvaluateNew(node.callee, node.arguments);\n      case \"ObjectExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-object-initializer\n          var object = {};\n          for (var prop of node.properties) {\n            if (prop.type === \"SpreadElement\") {\n              var fromValue = GetValue(Evaluate(prop.argument));\n              CopyDataProperties(object, fromValue, new Set());\n            } else {\n              if (prop.kind !== \"init\") {\n                throw new SyntaxError(\"Unsupported object getter/setter\");\n              }\n              var propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : EvaluateComputedPropertyName(prop.key);\n              if (propName === \"__proto__\") {\n                throw new TypeError(\"Setting '__proto__' property is not allowed\");\n              }\n              object[propName] = GetValue(Evaluate(prop.value));\n            }\n          }\n          return NormalCompletion(object);\n        }\n      case \"SequenceExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-comma-operator\n          var _result2;\n          for (var expr of node.expressions) {\n            _result2 = NormalCompletion(GetValue(Evaluate(expr)));\n          }\n          return _result2;\n        }\n      case \"TemplateLiteral\":\n        {\n          // https://tc39.es/ecma262/#sec-template-literals\n          var chunks = [node.quasis[0].value.cooked];\n          var index = 0;\n          for (var _expr of node.expressions) {\n            var val = GetValue(Evaluate(_expr));\n            chunks.push(String(val));\n            chunks.push(node.quasis[index += 1].value.cooked);\n          }\n          return NormalCompletion(chunks.join(\"\"));\n        }\n      case \"TaggedTemplateExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-tagged-templates\n          var tagRef = Evaluate(node.tag).Value;\n          var tagFunc = GetValue(tagRef);\n          sanitize(tagFunc);\n          return EvaluateCall(tagFunc, tagRef, node.quasi, node.tag);\n        }\n      case \"UnaryExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-unary-operators\n          var _ref = Evaluate(node.argument).Value;\n          if (!expressionOnly && node.operator === \"delete\") {\n            // Delete operator is supported only in function mode.\n            if (!(_ref instanceof ReferenceRecord)) {\n              return NormalCompletion(true);\n            }\n            // istanbul ignore else\n            if (IsPropertyReference(_ref)) {\n              var deleteStatus = delete _ref.Base[_ref.ReferenceName];\n              return NormalCompletion(deleteStatus);\n            }\n            // Should never reach here in strict mode.\n          }\n\n          if (node.operator === \"typeof\") {\n            if (_ref instanceof ReferenceRecord && _ref.Base === \"unresolvable\") {\n              return NormalCompletion(\"undefined\");\n            }\n            return NormalCompletion(typeof GetValue(_ref));\n          }\n          return NormalCompletion(ApplyUnaryOperator(GetValue(_ref), node.operator));\n        }\n    }\n    if (!expressionOnly) {\n      // Statements and assignments:\n      switch (node.type) {\n        case \"AssignmentExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-assignment-operators\n            if (node.operator === \"=\") {\n              if (!(node.left.type === \"ArrayPattern\" || node.left.type === \"ObjectPattern\")) {\n                var _lref = Evaluate(node.left).Value;\n                // Todo: IsAnonymousFunctionDefinition(lref)\n                var _rref = Evaluate(node.right);\n                var _rval = GetValue(_rref);\n                PutValue(_lref, _rval);\n                return NormalCompletion(_rval);\n              }\n              var _rref2 = Evaluate(node.right);\n              var _rval2 = GetValue(_rref2);\n              DestructuringAssignmentEvaluation(node.left, _rval2);\n              return NormalCompletion(_rval2);\n            }\n            // Operators other than `=`.\n            var lref = Evaluate(node.left).Value;\n            var lval = GetValue(lref);\n            var rref = Evaluate(node.right);\n            var rval = GetValue(rref);\n            var r = ApplyStringOrNumericAssignment(lval, node.operator, rval);\n            PutValue(lref, r);\n            return NormalCompletion(r);\n          }\n        case \"BlockStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-block\n            if (!node.body.length) {\n              return NormalCompletion(Empty);\n            }\n            var oldEnv = getRunningContext().LexicalEnvironment;\n            var blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.body, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            var blockValue = EvaluateStatementList(node.body);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return blockValue;\n          }\n        case \"BreakStatement\":\n          // https://tc39.es/ecma262/#sec-break-statement\n          return new CompletionRecord(\"break\", Empty);\n        case \"ContinueStatement\":\n          // https://tc39.es/ecma262/#sec-continue-statement\n          return new CompletionRecord(\"continue\", Empty);\n        case \"EmptyStatement\":\n          // https://tc39.es/ecma262/#sec-empty-statement\n          return NormalCompletion(Empty);\n        case \"DoWhileStatement\":\n          // https://tc39.es/ecma262/#sec-do-while-statement\n          return EvaluateBreakableStatement(DoWhileLoopEvaluation(node));\n        case \"ExpressionStatement\":\n        case \"TSAsExpression\":\n          // https://tc39.es/ecma262/#sec-expression-statement\n          return Evaluate(node.expression);\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n          // https://tc39.es/ecma262/#sec-for-in-and-for-of-statements\n          return EvaluateBreakableStatement(ForInOfLoopEvaluation(node));\n        case \"ForStatement\":\n          // https://tc39.es/ecma262/#sec-for-statement\n          return EvaluateBreakableStatement(ForLoopEvaluation(node));\n        case \"FunctionDeclaration\":\n          // https://tc39.es/ecma262/#sec-function-definitions\n          return NormalCompletion(Empty);\n        case \"FunctionExpression\":\n          // https://tc39.es/ecma262/#sec-function-defining-expressions\n          ThrowIfFunctionIsInvalid(node);\n          return NormalCompletion(InstantiateOrdinaryFunctionExpression(node));\n        case \"IfStatement\":\n          // https://tc39.es/ecma262/#sec-if-statement\n          return GetValue(Evaluate(node.test)) ? ((_hooks$beforeBranch = hooks.beforeBranch) !== null && _hooks$beforeBranch !== void 0 && _hooks$beforeBranch.call(hooks, node, \"if\"), UpdateEmpty(Evaluate(node.consequent), undefined)) : ((_hooks$beforeBranch2 = hooks.beforeBranch) !== null && _hooks$beforeBranch2 !== void 0 && _hooks$beforeBranch2.call(hooks, node, \"else\"), node.alternate) ? UpdateEmpty(Evaluate(node.alternate), undefined) : NormalCompletion(undefined);\n        case \"ReturnStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-return-statement\n            var v;\n            if (node.argument) {\n              var exprRef = Evaluate(node.argument);\n              v = GetValue(exprRef);\n            }\n            return new CompletionRecord(\"return\", v);\n          }\n        case \"ThrowStatement\":\n          // https://tc39.es/ecma262/#sec-throw-statement\n          throw GetValue(Evaluate(node.argument));\n        case \"UpdateExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-update-expressions\n            var lhs = Evaluate(node.argument).Value;\n            var oldValue = Number(GetValue(lhs));\n            var newValue = node.operator === \"++\" ? oldValue + 1 : oldValue - 1;\n            PutValue(lhs, newValue);\n            return NormalCompletion(node.prefix ? newValue : oldValue);\n          }\n        case \"SwitchCase\":\n          return EvaluateStatementList(node.consequent);\n        case \"SwitchStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-switch-statement\n            var _exprRef = Evaluate(node.discriminant);\n            var switchValue = GetValue(_exprRef);\n            var _oldEnv = getRunningContext().LexicalEnvironment;\n            var _blockEnv = new DeclarativeEnvironment(_oldEnv);\n            BlockDeclarationInstantiation(node.cases, _blockEnv);\n            getRunningContext().LexicalEnvironment = _blockEnv;\n            var R = CaseBlockEvaluation(node.cases, switchValue);\n            getRunningContext().LexicalEnvironment = _oldEnv;\n            return EvaluateBreakableStatement(R);\n          }\n        case \"TryStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-try-statement\n            var _R;\n            try {\n              _R = Evaluate(node.block);\n            } catch (error) {\n              if (node.handler) {\n                var _hooks$beforeEvaluate2;\n                (_hooks$beforeEvaluate2 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate2 === void 0 || _hooks$beforeEvaluate2.call(hooks, node.handler);\n                _R = CatchClauseEvaluation(node.handler, error);\n              } else {\n                throw error;\n              }\n            } finally {\n              if (node.finalizer) {\n                var F = Evaluate(node.finalizer);\n                if (F.Type !== \"normal\") {\n                  _R = F;\n                }\n              }\n            }\n            return _R;\n          }\n        case \"VariableDeclaration\":\n          {\n            // https://tc39.es/ecma262/#sec-declarations-and-the-variable-statement\n            var _result3;\n            for (var declarator of node.declarations) {\n              if (!declarator.init) {\n                // Assert: a declarator without init is always an identifier.\n                if (node.kind === \"var\") {\n                  _result3 = NormalCompletion(Empty);\n                } else {\n                  var _lhs = ResolveBinding(declarator.id.name);\n                  _result3 = InitializeReferencedBinding(_lhs, undefined);\n                }\n              } else if (declarator.id.type === \"Identifier\") {\n                var bindingId = declarator.id.name;\n                var _lhs2 = ResolveBinding(bindingId);\n                // Todo: IsAnonymousFunctionDefinition(Initializer)\n                var rhs = Evaluate(declarator.init);\n                var _value = GetValue(rhs);\n                _result3 = node.kind === \"var\" ? PutValue(_lhs2, _value) : InitializeReferencedBinding(_lhs2, _value);\n              } else {\n                var _rhs = Evaluate(declarator.init);\n                var _rval3 = GetValue(_rhs);\n                _result3 = BindingInitialization(declarator.id, _rval3, node.kind === \"var\" ? undefined : getRunningContext().LexicalEnvironment);\n              }\n            }\n            return _result3;\n          }\n        case \"WhileStatement\":\n          // https://tc39.es/ecma262/#sec-while-statement\n          return EvaluateBreakableStatement(WhileLoopEvaluation(node));\n      }\n    }\n    // eslint-disable-next-line no-console\n    throw new SyntaxError(\"Unsupported node type `\".concat(node.type, \"`\"));\n  }\n\n  // https://tc39.es/ecma262/#sec-execution-contexts\n  function getRunningContext() {\n    return executionContextStack[executionContextStack.length - 1];\n  }\n\n  // https://tc39.es/ecma262/#sec-resolvebinding\n  function ResolveBinding(name, env) {\n    if (!env) {\n      env = getRunningContext().LexicalEnvironment;\n    }\n    return GetIdentifierReference(env, name, true);\n  }\n\n  // Try statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation\n  function CatchClauseEvaluation(node, thrownValue) {\n    if (!node.param) {\n      return Evaluate(node.body);\n    }\n    var oldEnv = getRunningContext().LexicalEnvironment;\n    var catchEnv = new DeclarativeEnvironment(oldEnv);\n    for (var argName of collectBoundNames(node.param)) {\n      catchEnv.CreateMutableBinding(argName, false);\n    }\n    getRunningContext().LexicalEnvironment = catchEnv;\n    BindingInitialization(node.param, thrownValue, catchEnv);\n    var B = Evaluate(node.body);\n    getRunningContext().LexicalEnvironment = oldEnv;\n    return B;\n  }\n\n  // Iteration statements and switch statements.\n  // https://tc39.es/ecma262/#prod-BreakableStatement\n  function EvaluateBreakableStatement(stmtResult) {\n    return stmtResult.Type === \"break\" ? stmtResult.Value === Empty ? NormalCompletion(undefined) : NormalCompletion(stmtResult.Value) : stmtResult;\n  }\n\n  // Switch statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  function CaseBlockEvaluation(cases, input) {\n    var V;\n    var defaultCaseIndex = cases.findIndex(switchCase => !switchCase.test);\n    var hasDefaultCase = defaultCaseIndex >= 0;\n    var A = hasDefaultCase ? cases.slice(0, defaultCaseIndex) : cases;\n    var found = false;\n    for (var C of A) {\n      if (!found) {\n        found = CaseClauseIsSelected(C, input);\n      }\n      if (found) {\n        var _R2 = Evaluate(C);\n        if (_R2.Value !== Empty) {\n          V = _R2.Value;\n        }\n        if (_R2.Type !== \"normal\") {\n          return UpdateEmpty(_R2, V);\n        }\n      }\n    }\n    if (!hasDefaultCase) {\n      return NormalCompletion(V);\n    }\n    var foundInB = false;\n    var B = cases.slice(defaultCaseIndex + 1);\n    if (!found) {\n      for (var _C of B) {\n        if (!foundInB) {\n          foundInB = CaseClauseIsSelected(_C, input);\n        }\n        if (foundInB) {\n          var _R3 = Evaluate(_C);\n          if (_R3.Value !== Empty) {\n            V = _R3.Value;\n          }\n          if (_R3.Type !== \"normal\") {\n            return UpdateEmpty(_R3, V);\n          }\n        }\n      }\n    }\n    if (foundInB) {\n      return NormalCompletion(V);\n    }\n    var R = Evaluate(cases[defaultCaseIndex]);\n    if (R.Value !== Empty) {\n      V = R.Value;\n    }\n    if (R.Type !== \"normal\") {\n      return UpdateEmpty(R, V);\n    }\n\n    // NOTE: The following is another complete iteration of the second CaseClauses.\n    for (var _C2 of B) {\n      var _R4 = Evaluate(_C2);\n      if (_R4.Value !== Empty) {\n        V = _R4.Value;\n      }\n      if (_R4.Type !== \"normal\") {\n        return UpdateEmpty(_R4, V);\n      }\n    }\n    return NormalCompletion(V);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected\n  function CaseClauseIsSelected(C, input) {\n    var clauseSelector = GetValue(Evaluate(C.test));\n    return input === clauseSelector;\n  }\n\n  // While statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-whileloopevaluation\n  function WhileLoopEvaluation(node) {\n    var V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var exprValue = GetValue(Evaluate(node.test));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n      var stmtResult = Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n    }\n  }\n\n  // Do-while Statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-dowhileloopevaluation\n  function DoWhileLoopEvaluation(node) {\n    var V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var stmtResult = Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n      var exprValue = GetValue(Evaluate(node.test));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n    }\n  }\n\n  // For in/of statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofloopevaluation\n  function ForInOfLoopEvaluation(node) {\n    var lhs = node.left;\n    var isVariableDeclaration = lhs.type === \"VariableDeclaration\";\n    var lhsKind = isVariableDeclaration ? lhs.kind === \"var\" ? \"varBinding\" : \"lexicalBinding\" : \"assignment\";\n    var uninitializedBoundNames = lhsKind === \"lexicalBinding\" ? collectBoundNames(lhs) : [];\n    var iterationKind = node.type === \"ForInStatement\" ? \"enumerate\" : \"iterate\";\n    var keyResult = ForInOfHeadEvaluation(uninitializedBoundNames, node.right, iterationKind);\n    if (keyResult.Type !== \"normal\") {\n      // When enumerate, if the target is nil, a break completion will be returned.\n      return keyResult;\n    }\n    return ForInOfBodyEvaluation(lhs, node.body, keyResult.Value, iterationKind, lhsKind);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation\n  function ForInOfHeadEvaluation(uninitializedBoundNames, expr, iterationKind) {\n    var runningContext = getRunningContext();\n    var oldEnv = runningContext.LexicalEnvironment;\n    if (uninitializedBoundNames.length > 0) {\n      var newEnv = new DeclarativeEnvironment(oldEnv);\n      for (var name of uninitializedBoundNames) {\n        newEnv.CreateMutableBinding(name, false);\n      }\n      runningContext.LexicalEnvironment = newEnv;\n    }\n    var exprRef = Evaluate(expr);\n    runningContext.LexicalEnvironment = oldEnv;\n    var exprValue = GetValue(exprRef);\n    if (iterationKind === \"enumerate\") {\n      if (exprValue === null || exprValue === undefined) {\n        return new CompletionRecord(\"break\", Empty);\n      }\n      var _iterator = EnumerateObjectProperties(exprValue);\n      return NormalCompletion(_iterator);\n    }\n    var iterator = CreateListIteratorRecord(exprValue);\n    return NormalCompletion(iterator);\n  }\n  function ForInOfBodyEvaluation(node, stmt, iteratorRecord, iterationKind, lhsKind) {\n    var lhs = lhsKind === \"assignment\" ? node : node.declarations[0].id;\n    var oldEnv = getRunningContext().LexicalEnvironment;\n    var V;\n    // When `destructuring` is false,\n    // For `node` whose `kind` is assignment:\n    //   `lhs` is an `Identifier` or a `MemberExpression`,\n    // Otherwise:\n    //   `lhs` is an `Identifier`.\n    var destructuring = lhs.type === \"ObjectPattern\" || lhs.type === \"ArrayPattern\";\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var {\n        done,\n        value: nextValue\n      } = iteratorRecord.next();\n      if (done) {\n        return NormalCompletion(V);\n      }\n      var lhsRef = void 0;\n      var iterationEnv = void 0;\n      if (lhsKind === \"lexicalBinding\") {\n        iterationEnv = new DeclarativeEnvironment(oldEnv);\n        ForDeclarationBindingInstantiation(node, iterationEnv);\n        getRunningContext().LexicalEnvironment = iterationEnv;\n        if (!destructuring) {\n          var [lhsName] = collectBoundNames(lhs);\n          lhsRef = ResolveBinding(lhsName);\n        }\n      } else if (!destructuring) {\n        lhsRef = Evaluate(lhs).Value;\n      }\n      destructuring ? lhsKind === \"assignment\" ? DestructuringAssignmentEvaluation(lhs, nextValue) : lhsKind === \"varBinding\" ? BindingInitialization(lhs, nextValue, undefined) : BindingInitialization(lhs, nextValue, iterationEnv) : lhsKind === \"lexicalBinding\" ? InitializeReferencedBinding(lhsRef, nextValue) : PutValue(lhsRef, nextValue);\n      var result = Evaluate(stmt);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      if (!LoopContinues(result)) {\n        var status = UpdateEmpty(result, V);\n        if (!(iterationKind === \"enumerate\" || iteratorRecord.return === undefined)) {\n          // Perform *IteratorClose*\n          // https://tc39.es/ecma262/#sec-iteratorclose\n          var innerResult = iteratorRecord.return();\n          if (!innerResult || ![\"object\", \"function\"].includes(typeof innerResult)) {\n            throw new TypeError(\"Iterator result is not an object\");\n          }\n        }\n        return status;\n      }\n      if (result.Value !== Empty) {\n        V = result.Value;\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-enumerate-object-properties\n  function* EnumerateObjectProperties(value) {\n    for (var _key in value) {\n      yield _key;\n    }\n  }\n\n  // For statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forloopevaluation\n  function ForLoopEvaluation(node) {\n    var _node$init;\n    if (((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\") {\n      // `for (var … ; … ; … ) …`\n      if (node.init.kind === \"var\") {\n        Evaluate(node.init);\n        return ForBodyEvaluation(node.test, node.update, node.body, []);\n      }\n      // `for (let/const … ; … ; … ) …`\n      var oldEnv = getRunningContext().LexicalEnvironment;\n      var loopEnv = new DeclarativeEnvironment(oldEnv);\n      var isConst = node.init.kind === \"const\";\n      var boundNames = collectBoundNames(node.init);\n      for (var dn of boundNames) {\n        if (isConst) {\n          loopEnv.CreateImmutableBinding(dn, true);\n        } else {\n          loopEnv.CreateMutableBinding(dn, false);\n        }\n      }\n      getRunningContext().LexicalEnvironment = loopEnv;\n      Evaluate(node.init);\n      var perIterationLets = isConst ? [] : Array.from(boundNames);\n      var bodyResult = ForBodyEvaluation(node.test, node.update, node.body, perIterationLets);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      return bodyResult;\n    }\n    // `for ( … ; … ; … ) …`\n    if (node.init) {\n      var exprRef = Evaluate(node.init);\n      GetValue(exprRef);\n    }\n    return ForBodyEvaluation(node.test, node.update, node.body, []);\n  }\n\n  // https://tc39.es/ecma262/#sec-forbodyevaluation\n  function ForBodyEvaluation(test, increment, stmt, perIterationBindings) {\n    CreatePerIterationEnvironment(perIterationBindings);\n    var V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (test) {\n        var testRef = Evaluate(test);\n        var testValue = GetValue(testRef);\n        if (!testValue) {\n          return NormalCompletion(V);\n        }\n      }\n      var result = Evaluate(stmt);\n      if (!LoopContinues(result)) {\n        return UpdateEmpty(result, V);\n      }\n      if (result.Value) {\n        V = result.Value;\n      }\n      CreatePerIterationEnvironment(perIterationBindings);\n      if (increment) {\n        var incRef = Evaluate(increment);\n        GetValue(incRef);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-createperiterationenvironment\n  function CreatePerIterationEnvironment(perIterationBindings) {\n    if (perIterationBindings.length === 0) {\n      return;\n    }\n    var lastIterationEnv = getRunningContext().LexicalEnvironment;\n    var outer = lastIterationEnv.OuterEnv;\n    var thisIterationEnv = new DeclarativeEnvironment(outer);\n    for (var bn of perIterationBindings) {\n      thisIterationEnv.CreateMutableBinding(bn, false);\n      var lastValue = lastIterationEnv.GetBindingValue(bn, false);\n      thisIterationEnv.InitializeBinding(bn, lastValue);\n    }\n    getRunningContext().LexicalEnvironment = thisIterationEnv;\n  }\n\n  // Destructuring assignments.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-destructuringassignmentevaluation\n  function DestructuringAssignmentEvaluation(pattern, value) {\n    if (pattern.type === \"ObjectPattern\") {\n      RequireObjectCoercible(value);\n      if (pattern.properties.length > 0) {\n        PropertyDestructuringAssignmentEvaluation(pattern.properties, value);\n      }\n      return NormalCompletion(Empty);\n    }\n    var iteratorRecord = CreateListIteratorRecord(value);\n    return IteratorDestructuringAssignmentEvaluation(pattern.elements, iteratorRecord);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-propertydestructuringassignmentevaluation\n  function PropertyDestructuringAssignmentEvaluation(properties, value) {\n    var excludedNames = new Set();\n    for (var prop of properties) {\n      if (prop.type === \"Property\") {\n        var propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : EvaluateComputedPropertyName(prop.key);\n        var valueTarget = prop.value.type === \"AssignmentPattern\" ? prop.value.left : prop.value;\n        if (valueTarget.type === \"Identifier\") {\n          var lref = ResolveBinding(valueTarget.name);\n          var v = GetV(value, propName);\n          if (prop.value.type === \"AssignmentPattern\" && v === undefined) {\n            // Todo(steve): check IsAnonymousFunctionDefinition(Initializer)\n            var defaultValue = Evaluate(prop.value.right);\n            v = GetValue(defaultValue);\n          }\n          PutValue(lref, v);\n          excludedNames.add(propName);\n        } else {\n          KeyedDestructuringAssignmentEvaluation(prop.value, value, propName);\n          excludedNames.add(propName);\n        }\n      } else {\n        RestDestructuringAssignmentEvaluation(prop, value, excludedNames);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation\n  function KeyedDestructuringAssignmentEvaluation(node, value, propertyName) {\n    var assignmentTarget = node.type === \"AssignmentPattern\" ? node.left : node;\n    var isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n    var lref;\n    if (!isObjectOrArray) {\n      lref = Evaluate(assignmentTarget).Value;\n    }\n    var v = GetV(value, propertyName);\n    var rhsValue;\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      // Todo(steve): check IsAnonymousFunctionDefinition(Initializer)\n      var defaultValue = Evaluate(node.right);\n      rhsValue = GetValue(defaultValue);\n    } else {\n      rhsValue = v;\n    }\n    if (isObjectOrArray) {\n      return DestructuringAssignmentEvaluation(assignmentTarget, rhsValue);\n    }\n    return PutValue(lref, rhsValue);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation\n  function RestDestructuringAssignmentEvaluation(restProperty, value, excludedNames) {\n    var lref = Evaluate(restProperty.argument).Value;\n    var restObj = CopyDataProperties({}, value, excludedNames);\n    return PutValue(lref, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n  function IteratorDestructuringAssignmentEvaluation(elements, iteratorRecord) {\n    var status = NormalCompletion(Empty);\n    for (var element of elements) {\n      if (!element) {\n        iteratorRecord.next();\n        status = NormalCompletion(Empty);\n        continue;\n      }\n      var assignmentTarget = element.type === \"RestElement\" ? element.argument : element.type === \"AssignmentPattern\" ? element.left : element;\n      var isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n      var lref = void 0;\n      if (!isObjectOrArray) {\n        lref = Evaluate(assignmentTarget).Value;\n      }\n      var v = void 0;\n      if (element.type !== \"RestElement\") {\n        var {\n          done,\n          value: nextValue\n        } = iteratorRecord.next();\n        var _value2 = done ? undefined : nextValue;\n        if (element.type === \"AssignmentPattern\" && _value2 === undefined) {\n          // Todo(steve): check IsAnonymousFunctionDefinition(Initializer)\n          var defaultValue = Evaluate(element.right);\n          v = GetValue(defaultValue);\n        } else {\n          v = _value2;\n        }\n      } else {\n        // RestElement\n        v = [];\n        var n = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          var {\n            done: _done,\n            value: _nextValue\n          } = iteratorRecord.next();\n          if (_done) {\n            break;\n          }\n          v[n] = _nextValue;\n          n++;\n        }\n      }\n      if (isObjectOrArray) {\n        status = DestructuringAssignmentEvaluation(assignmentTarget, v);\n      } else {\n        status = PutValue(lref, v);\n      }\n    }\n    return status;\n  }\n\n  // Object expressions.\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key\n  function EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {\n    var propertyNameReference = Evaluate(expression);\n    var propertyNameValue = GetValue(propertyNameReference);\n    var propertyKey = ToPropertyKey(propertyNameValue);\n    return new ReferenceRecord(baseValue, propertyKey, strict);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key\n  function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifier, strict) {\n    var propertyNameString = identifier.name;\n    return new ReferenceRecord(baseValue, propertyNameString, strict);\n  }\n\n  // Block statements.\n  // https://tc39.es/ecma262/#sec-blockdeclarationinstantiation\n  function BlockDeclarationInstantiation(code, env) {\n    var declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    for (var d of declarations) {\n      var IsConstantDeclaration = d.type === \"VariableDeclaration\" && d.kind === \"const\";\n      for (var dn of collectBoundNames(d)) {\n        if (IsConstantDeclaration) {\n          env.CreateImmutableBinding(dn, true);\n        } else {\n          env.CreateMutableBinding(dn, false);\n        }\n      }\n      if (d.type === \"FunctionDeclaration\") {\n        var [_fn] = collectBoundNames(d);\n        var _fo = InstantiateFunctionObject(d, env);\n        env.InitializeBinding(_fn, _fo);\n      }\n    }\n  }\n\n  // Function declarations and expressions.\n  // https://tc39.es/ecma262/#sec-evaluatecall\n  function EvaluateCall(func, ref, args, callee) {\n    var thisValue;\n    if (ref instanceof ReferenceRecord) {\n      if (IsPropertyReference(ref)) {\n        thisValue = ref.Base;\n      }\n    }\n    var argList = ArgumentListEvaluation(args);\n    if (typeof func !== \"function\") {\n      var funcName = codeSource.substring(callee.start, callee.end);\n      throw new TypeError(\"\".concat(funcName, \" is not a function\"));\n    }\n    var result = func.apply(thisValue, argList);\n    sanitize(result);\n    return NormalCompletion(result);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluatenew\n  function EvaluateNew(constructExpr, args) {\n    var ref = Evaluate(constructExpr);\n    var constructor = GetValue(ref);\n    var argList = ArgumentListEvaluation(args);\n    if (typeof constructor !== \"function\" || constructor[IsConstructor] === false) {\n      var constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(\"\".concat(constructorName, \" is not a constructor\"));\n    }\n    if (!isAllowedConstructor(constructor)) {\n      var _constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(\"\".concat(_constructorName, \" is not an allowed constructor\"));\n    }\n    return NormalCompletion(new constructor(...argList));\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-argumentlistevaluation\n  function ArgumentListEvaluation(args) {\n    var array = [];\n    if (Array.isArray(args)) {\n      for (var arg of args) {\n        if (arg.type === \"SpreadElement\") {\n          var spreadValues = GetValue(Evaluate(arg.argument));\n          array.push(...spreadValues);\n        } else {\n          array.push(GetValue(Evaluate(arg)));\n        }\n      }\n    } else {\n      array.push(GetTemplateObject(args));\n      for (var expr of args.expressions) {\n        array.push(GetValue(Evaluate(expr)));\n      }\n    }\n    return array;\n  }\n\n  // https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n  function CallFunction(closure, args) {\n    var _hooks$beforeCall;\n    (_hooks$beforeCall = hooks.beforeCall) === null || _hooks$beforeCall === void 0 || _hooks$beforeCall.call(hooks, closure[SourceNode]);\n    PrepareForOrdinaryCall(closure);\n    var result = OrdinaryCallEvaluateBody(closure, args);\n    executionContextStack.pop();\n    if (result.Type === \"return\") {\n      return result.Value;\n    }\n    return undefined;\n  }\n\n  // https://tc39.es/ecma262/#sec-prepareforordinarycall\n  function PrepareForOrdinaryCall(F) {\n    var calleeContext = new ExecutionContext();\n    calleeContext.Function = F;\n    var localEnv = new FunctionEnvironment(F[Environment]);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    executionContextStack.push(calleeContext);\n    return calleeContext;\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinarycallevaluatebody\n  function OrdinaryCallEvaluateBody(F, args) {\n    return EvaluateFunctionBody(F[ECMAScriptCode], F, args);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-evaluatefunctionbody\n  function EvaluateFunctionBody(body, F, args) {\n    FunctionDeclarationInstantiation(F, args);\n    if (Array.isArray(body)) {\n      return EvaluateStatementList(body);\n    }\n    return new CompletionRecord(\"return\", GetValue(Evaluate(body)));\n  }\n\n  // https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation\n  function EvaluateStatementList(statements) {\n    var result = NormalCompletion(Empty);\n    for (var stmt of statements) {\n      var s = Evaluate(stmt);\n      if (s.Type !== \"normal\") {\n        return s;\n      }\n      result = UpdateEmpty(result, s.Value);\n    }\n    return result;\n  }\n\n  // https://tc39.es/ecma262/#sec-functiondeclarationinstantiation\n  function FunctionDeclarationInstantiation(func, args) {\n    var calleeContext = getRunningContext();\n    var code = func[ECMAScriptCode];\n    var formals = func[FormalParameters];\n    var parameterNames = collectBoundNames(formals);\n    var hasParameterExpressions = containsExpression(formals);\n    var varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    var varNames = collectBoundNames(varDeclarations);\n\n    // `functionNames` ∈ `varNames`\n    // `functionsToInitialize` ≈ `functionNames`\n    var functionNames = [];\n    var functionsToInitialize = [];\n    for (var i = varDeclarations.length - 1; i >= 0; i--) {\n      var d = varDeclarations[i];\n      if (d.type === \"FunctionDeclaration\") {\n        ThrowIfFunctionIsInvalid(d);\n        var [_fn2] = collectBoundNames(d);\n        if (!functionNames.includes(_fn2)) {\n          functionNames.unshift(_fn2);\n          functionsToInitialize.unshift(d);\n        }\n      } else if (rules !== null && rules !== void 0 && rules.noVar) {\n        throw new SyntaxError(\"Var declaration is not recommended, use `let` or `const` instead\");\n      }\n    }\n    var env = calleeContext.LexicalEnvironment;\n    for (var paramName of parameterNames) {\n      // In strict mode, it's guaranteed no duplicate params exist.\n      env.CreateMutableBinding(paramName, false);\n    }\n    var iteratorRecord = CreateListIteratorRecord(args);\n    IteratorBindingInitialization(formals, iteratorRecord, env);\n    var varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      // `varNames` are unique.\n      for (var n of varNames) {\n        if (!parameterNames.includes(n)) {\n          env.CreateMutableBinding(n, false);\n          env.InitializeBinding(n, undefined);\n        }\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new DeclarativeEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      // `varNames` are unique.\n      for (var _n of varNames) {\n        varEnv.CreateMutableBinding(_n, false);\n        var initialValue = void 0;\n        if (parameterNames.includes(_n) && !functionNames.includes(_n)) {\n          initialValue = env.GetBindingValue(_n, false);\n        }\n        varEnv.InitializeBinding(_n, initialValue);\n        // NOTE: A var with the same name as a formal parameter initially has\n        // the same value as the corresponding initialized parameter.\n      }\n    }\n\n    var lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    var lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    for (var _d of lexDeclarations) {\n      for (var dn of collectBoundNames(_d)) {\n        // Only lexical VariableDeclaration here in top-level.\n        if (_d.kind === \"const\") {\n          lexEnv.CreateImmutableBinding(dn, true);\n        } else {\n          lexEnv.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n    for (var f of functionsToInitialize) {\n      var [_fn3] = collectBoundNames(f);\n      var _fo2 = InstantiateFunctionObject(f, lexEnv);\n      varEnv.SetMutableBinding(_fn3, _fo2, false);\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatefunctionobject\n  function InstantiateFunctionObject(func, scope) {\n    return OrdinaryFunctionCreate(func, scope, true);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression\n  function InstantiateOrdinaryFunctionExpression(functionExpression) {\n    var scope = getRunningContext().LexicalEnvironment;\n    if (functionExpression.id) {\n      var name = functionExpression.id.name;\n      var funcEnv = new DeclarativeEnvironment(scope);\n      funcEnv.CreateImmutableBinding(name, false);\n      var closure = OrdinaryFunctionCreate(functionExpression, funcEnv, true);\n      funcEnv.InitializeBinding(name, closure);\n      return closure;\n    } else {\n      var _closure = OrdinaryFunctionCreate(functionExpression, scope, true);\n      return _closure;\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression\n  function InstantiateArrowFunctionExpression(arrowFunction) {\n    var scope = getRunningContext().LexicalEnvironment;\n    var closure = OrdinaryFunctionCreate(arrowFunction, scope, false);\n    return closure;\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinaryfunctioncreate\n  function OrdinaryFunctionCreate(sourceNode, scope, isConstructor) {\n    var F = function () {\n      // eslint-disable-next-line prefer-rest-params\n      return CallFunction(F, arguments);\n    };\n    Object.defineProperties(F, {\n      [SourceNode]: {\n        value: sourceNode\n      },\n      [FormalParameters]: {\n        value: sourceNode.params\n      },\n      [ECMAScriptCode]: {\n        value: sourceNode.body.type === \"BlockStatement\" ? sourceNode.body.body : sourceNode.body\n      },\n      [Environment]: {\n        value: scope\n      },\n      [IsConstructor]: {\n        value: isConstructor\n      }\n    });\n    return F;\n  }\n\n  // Patterns initialization.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization\n  function BindingInitialization(node, value, environment) {\n    switch (node.type) {\n      case \"Identifier\":\n        return InitializeBoundName(node.name, value, environment);\n      case \"ObjectPattern\":\n        RequireObjectCoercible(value);\n        return PropertyBindingInitialization(node.properties, value, environment);\n      case \"ArrayPattern\":\n        {\n          var iteratorRecord = CreateListIteratorRecord(value);\n          return IteratorBindingInitialization(node.elements, iteratorRecord, environment);\n        }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  function PropertyBindingInitialization(properties, value, environment) {\n    var excludedNames = new Set();\n    for (var prop of properties) {\n      if (prop.type === \"RestElement\") {\n        return RestBindingInitialization(prop, value, environment, excludedNames);\n      }\n      if (!prop.computed && prop.key.type === \"Identifier\") {\n        KeyedBindingInitialization(prop.value, value, environment, prop.key.name);\n        excludedNames.add(prop.key.name);\n      } else {\n        var P = EvaluateComputedPropertyName(prop.key);\n        KeyedBindingInitialization(prop.value, value, environment, P);\n        excludedNames.add(P);\n      }\n    }\n    return NormalCompletion(Empty);\n  }\n\n  // https://tc39.es/ecma262/#prod-ComputedPropertyName\n  function EvaluateComputedPropertyName(node) {\n    var propName = GetValue(Evaluate(node));\n    return ToPropertyKey(propName);\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization\n  function RestBindingInitialization(restProperty, value, environment, excludedNames) {\n    var lhs = ResolveBinding(restProperty.argument.name, environment);\n    var restObj = CopyDataProperties({}, value, excludedNames);\n    if (!environment) {\n      return PutValue(lhs, restObj);\n    }\n    return InitializeReferencedBinding(lhs, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization\n  function IteratorBindingInitialization(elements, iteratorRecord, environment) {\n    if (elements.length === 0) {\n      return NormalCompletion(Empty);\n    }\n    var result;\n    for (var _node of elements) {\n      if (!_node) {\n        // Elision element.\n        iteratorRecord.next();\n        result = NormalCompletion(Empty);\n      } else if (_node.type === \"RestElement\") {\n        // Rest element.\n        if (_node.argument.type === \"Identifier\") {\n          var lhs = ResolveBinding(_node.argument.name, environment);\n          var A = [];\n          var n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            var {\n              done,\n              value: _value3\n            } = iteratorRecord.next();\n            if (done) {\n              result = environment ? InitializeReferencedBinding(lhs, A) : PutValue(lhs, A);\n              break;\n            }\n            A[n] = _value3;\n            n++;\n          }\n        } else {\n          var _A = [];\n          var _n2 = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            var {\n              done: _done2,\n              value: _value4\n            } = iteratorRecord.next();\n            if (_done2) {\n              result = BindingInitialization(_node.argument, _A, environment);\n              break;\n            }\n            _A[_n2] = _value4;\n            _n2++;\n          }\n        }\n      } else {\n        // Normal element.\n        var bindingElement = _node.type === \"AssignmentPattern\" ? _node.left : _node;\n        switch (bindingElement.type) {\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n            {\n              var v = void 0;\n              var {\n                done: _done3,\n                value: _value5\n              } = iteratorRecord.next();\n              if (!_done3) {\n                v = _value5;\n              }\n              if (_node.type === \"AssignmentPattern\" && v === undefined) {\n                var defaultValue = Evaluate(_node.right);\n                v = GetValue(defaultValue);\n              }\n              result = BindingInitialization(bindingElement, v, environment);\n              break;\n            }\n          case \"Identifier\":\n            {\n              var bindingId = bindingElement.name;\n              var _lhs3 = ResolveBinding(bindingId, environment);\n              var _v = void 0;\n              var {\n                done: _done4,\n                value: _value6\n              } = iteratorRecord.next();\n              if (!_done4) {\n                _v = _value6;\n              }\n              if (_node.type === \"AssignmentPattern\" && _v === undefined) {\n                // IsAnonymousFunctionDefinition(Initializer)\n                var _defaultValue = Evaluate(_node.right);\n                _v = GetValue(_defaultValue);\n              }\n              result = environment ? InitializeReferencedBinding(_lhs3, _v) : PutValue(_lhs3, _v);\n              break;\n            }\n        }\n      }\n    }\n    return result;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization\n  function KeyedBindingInitialization(node, value, environment, propertyName) {\n    var isIdentifier = node.type === \"Identifier\" || node.type === \"AssignmentPattern\" && node.left.type === \"Identifier\";\n    if (isIdentifier) {\n      var bindingId = node.type === \"Identifier\" ? node.name : node.left.name;\n      var lhs = ResolveBinding(bindingId, environment);\n      var _v2 = GetV(value, propertyName);\n      if (node.type === \"AssignmentPattern\" && _v2 === undefined) {\n        // If IsAnonymousFunctionDefinition(Initializer)\n        var defaultValue = Evaluate(node.right);\n        _v2 = GetValue(defaultValue);\n      }\n      if (!environment) {\n        return PutValue(lhs, _v2);\n      }\n      return InitializeReferencedBinding(lhs, _v2);\n    }\n    var v = GetV(value, propertyName);\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      var _defaultValue2 = Evaluate(node.right);\n      v = GetValue(_defaultValue2);\n    }\n    return BindingInitialization(node.type === \"AssignmentPattern\" ? node.left : node, v, environment);\n  }\n\n  // https://tc39.es/ecma262/#sec-initializeboundname\n  function InitializeBoundName(name, value, environment) {\n    // Assert: environment is always present.\n    environment.InitializeBinding(name, value);\n    return NormalCompletion(Empty);\n  }\n  function ThrowIfFunctionIsInvalid(func) {\n    if (func.async || func.generator) {\n      throw new SyntaxError(\"\".concat(func.async ? \"Async\" : \"Generator\", \" function is not allowed\"));\n    }\n    if (expressionOnly && !func.expression) {\n      throw new SyntaxError(\"Only an `Expression` is allowed in `ArrowFunctionExpression`'s body\");\n    }\n  }\n  if (expressionOnly) {\n    return GetValue(Evaluate(rootAst));\n  }\n  (_hooks$beforeEvaluate3 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate3 === void 0 || _hooks$beforeEvaluate3.call(hooks, rootAst);\n  ThrowIfFunctionIsInvalid(rootAst);\n  var [fn] = collectBoundNames(rootAst);\n  // Create an immutable binding for the root function.\n  rootEnv.CreateImmutableBinding(fn, true);\n  var fo = InstantiateFunctionObject(rootAst, rootEnv);\n  rootEnv.InitializeBinding(fn, fo);\n  return fo;\n}\n//# sourceMappingURL=cook.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class AnalysisContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n  }\n}\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class AnalysisEnvironment {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingSet\", new Set());\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingSet.has(name);\n  }\n  CreateBinding(name) {\n    this.bindingSet.add(name);\n  }\n}\n//# sourceMappingURL=AnalysisContext.js.map","import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport { hasOwnProperty } from \"./hasOwnProperty.js\";\nimport { AnalysisContext, AnalysisEnvironment } from \"./AnalysisContext.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\n/**\n * Analysis an AST of a storyboard function or an evaluation expression.\n *\n * @param rootAst - The root AST.\n * @param options - Analysis options.\n * @returns A set of global variables the root AST attempts to access.\n */\nexport function precook(rootAst) {\n  var {\n    expressionOnly,\n    visitors,\n    withParent,\n    hooks = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attemptToVisitGlobals = new Set();\n  var analysisContextStack = [];\n  var rootEnv = new AnalysisEnvironment(null);\n  var rootContext = new AnalysisContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  analysisContextStack.push(rootContext);\n  function getRunningContext() {\n    return analysisContextStack[analysisContextStack.length - 1];\n  }\n  function visit(node) {\n    if (visitors && hasOwnProperty(visitors, node.type)) {\n      visitors[node.type](node);\n    }\n  }\n  function EvaluateChildren(node, keys, parent) {\n    for (var key of keys) {\n      Evaluate(node[key], parent === null || parent === void 0 ? void 0 : parent.concat({\n        node,\n        key\n      }));\n    }\n  }\n  function Evaluate(node, parent) {\n    if (Array.isArray(node)) {\n      node.forEach((n, index) => {\n        Evaluate(n, parent ? parent.slice(0, -1).concat(_objectSpread(_objectSpread({}, parent[parent.length - 1]), {}, {\n          index\n        })) : parent);\n      });\n    } else if (node) {\n      var _hooks$beforeVisit, _hooks$beforeVisitUnk;\n      // `node` maybe `null` in some cases.\n      (_hooks$beforeVisit = hooks.beforeVisit) === null || _hooks$beforeVisit === void 0 || _hooks$beforeVisit.call(hooks, node, parent);\n      visit(node);\n      // Expressions:\n      switch (node.type) {\n        case \"Identifier\":\n          if (!ResolveBinding(node.name)) {\n            var _hooks$beforeVisitGlo;\n            (_hooks$beforeVisitGlo = hooks.beforeVisitGlobal) === null || _hooks$beforeVisitGlo === void 0 || _hooks$beforeVisitGlo.call(hooks, node, parent);\n            attemptToVisitGlobals.add(node.name);\n          }\n          return;\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          EvaluateChildren(node, [\"elements\"], parent);\n          return;\n        case \"ArrowFunctionExpression\":\n          {\n            var env = getRunningContext().LexicalEnvironment;\n            var closure = OrdinaryFunctionCreate(node, env);\n            CallFunction(closure, parent);\n            return;\n          }\n        case \"AssignmentPattern\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          EvaluateChildren(node, [\"left\", \"right\"], parent);\n          return;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          EvaluateChildren(node, [\"callee\", \"arguments\"], parent);\n          return;\n        case \"ChainExpression\":\n          EvaluateChildren(node, [\"expression\"], parent);\n          return;\n        case \"ConditionalExpression\":\n          EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n          return;\n        case \"MemberExpression\":\n          EvaluateChildren(node, [\"object\"], parent);\n          if (node.computed) {\n            EvaluateChildren(node, [\"property\"], parent);\n          }\n          return;\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          EvaluateChildren(node, [\"properties\"], parent);\n          return;\n        case \"Property\":\n          if (node.computed) {\n            EvaluateChildren(node, [\"key\"], parent);\n          }\n          EvaluateChildren(node, [\"value\"], parent);\n          return;\n        case \"RestElement\":\n        case \"SpreadElement\":\n        case \"UnaryExpression\":\n          EvaluateChildren(node, [\"argument\"], parent);\n          return;\n        case \"SequenceExpression\":\n        case \"TemplateLiteral\":\n          EvaluateChildren(node, [\"expressions\"], parent);\n          return;\n        case \"TaggedTemplateExpression\":\n          EvaluateChildren(node, [\"tag\", \"quasi\"], parent);\n          return;\n        case \"Literal\":\n          return;\n      }\n      if (!expressionOnly) {\n        // Statements and assignments:\n        switch (node.type) {\n          case \"AssignmentExpression\":\n            EvaluateChildren(node, [\"right\", \"left\"], parent);\n            return;\n          case \"BlockStatement\":\n            {\n              if (!node.body.length) {\n                return;\n              }\n              var runningContext = getRunningContext();\n              var oldEnv = runningContext.LexicalEnvironment;\n              var blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.body, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"BreakStatement\":\n          case \"ContinueStatement\":\n          case \"EmptyStatement\":\n            return;\n          case \"CatchClause\":\n            {\n              var _runningContext = getRunningContext();\n              var _oldEnv = _runningContext.LexicalEnvironment;\n              var catchEnv = new AnalysisEnvironment(_oldEnv);\n              BoundNamesInstantiation(node.param, catchEnv);\n              _runningContext.LexicalEnvironment = catchEnv;\n              EvaluateChildren(node, [\"param\", \"body\"], parent);\n              _runningContext.LexicalEnvironment = _oldEnv;\n              return;\n            }\n          case \"DoWhileStatement\":\n            EvaluateChildren(node, [\"body\", \"test\"], parent);\n            return;\n          case \"ExpressionStatement\":\n          case \"TSAsExpression\":\n            EvaluateChildren(node, [\"expression\"], parent);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            {\n              // ForIn/OfHeadEvaluation\n              var lexicalBinding = node.left.type === \"VariableDeclaration\" && node.left.kind !== \"var\";\n              var _runningContext2 = getRunningContext();\n              var _oldEnv2 = _runningContext2.LexicalEnvironment;\n              if (lexicalBinding) {\n                var newEnv = new AnalysisEnvironment(_oldEnv2);\n                BoundNamesInstantiation(node.left, newEnv);\n                _runningContext2.LexicalEnvironment = newEnv;\n              }\n              EvaluateChildren(node, [\"right\"], parent);\n              _runningContext2.LexicalEnvironment = _oldEnv2;\n\n              // ForIn/OfBodyEvaluation\n              if (lexicalBinding) {\n                var iterationEnv = new AnalysisEnvironment(_oldEnv2);\n                BoundNamesInstantiation(node.left, iterationEnv);\n                _runningContext2.LexicalEnvironment = iterationEnv;\n              }\n              EvaluateChildren(node, [\"left\", \"body\"], parent);\n              _runningContext2.LexicalEnvironment = _oldEnv2;\n              return;\n            }\n          case \"ForStatement\":\n            {\n              var _node$init;\n              var _lexicalBinding = ((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\" && node.init.kind !== \"var\";\n              var _runningContext3 = getRunningContext();\n              var _oldEnv3 = _runningContext3.LexicalEnvironment;\n              if (_lexicalBinding) {\n                var loopEnv = new AnalysisEnvironment(_oldEnv3);\n                BoundNamesInstantiation(node.init, loopEnv);\n                _runningContext3.LexicalEnvironment = loopEnv;\n              }\n              EvaluateChildren(node, [\"init\", \"test\", \"body\", \"update\"], parent);\n              _runningContext3.LexicalEnvironment = _oldEnv3;\n              return;\n            }\n          case \"FunctionDeclaration\":\n            {\n              var [fn] = collectBoundNames(node);\n              var _env = getRunningContext().LexicalEnvironment;\n              var fo = OrdinaryFunctionCreate(node, _env);\n              _env.CreateBinding(fn);\n              CallFunction(fo, parent);\n              return;\n            }\n          case \"FunctionExpression\":\n            {\n              var _closure = InstantiateOrdinaryFunctionExpression(node);\n              CallFunction(_closure, parent);\n              return;\n            }\n          case \"IfStatement\":\n            EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n            return;\n          case \"ReturnStatement\":\n          case \"ThrowStatement\":\n          case \"UpdateExpression\":\n            EvaluateChildren(node, [\"argument\"], parent);\n            return;\n          case \"SwitchCase\":\n            EvaluateChildren(node, [\"test\", \"consequent\"], parent);\n            return;\n          case \"SwitchStatement\":\n            {\n              EvaluateChildren(node, [\"discriminant\"], parent);\n              var _runningContext4 = getRunningContext();\n              var _oldEnv4 = _runningContext4.LexicalEnvironment;\n              var _blockEnv = new AnalysisEnvironment(_oldEnv4);\n              BlockDeclarationInstantiation(node.cases, _blockEnv);\n              _runningContext4.LexicalEnvironment = _blockEnv;\n              EvaluateChildren(node, [\"cases\"], parent);\n              _runningContext4.LexicalEnvironment = _oldEnv4;\n              return;\n            }\n          case \"TryStatement\":\n            EvaluateChildren(node, [\"block\", \"handler\", \"finalizer\"], parent);\n            return;\n          case \"VariableDeclaration\":\n            EvaluateChildren(node, [\"declarations\"], parent);\n            return;\n          case \"VariableDeclarator\":\n            EvaluateChildren(node, [\"id\", \"init\"], parent);\n            return;\n          case \"WhileStatement\":\n            EvaluateChildren(node, [\"test\", \"body\"], parent);\n            return;\n        }\n      }\n      var silent = (_hooks$beforeVisitUnk = hooks.beforeVisitUnknown) === null || _hooks$beforeVisitUnk === void 0 ? void 0 : _hooks$beforeVisitUnk.call(hooks, node, parent);\n      if (!silent) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Unsupported node type `\".concat(node.type, \"`\"));\n      }\n    }\n  }\n  function BoundNamesInstantiation(declarations, env) {\n    for (var name of collectBoundNames(declarations)) {\n      env.CreateBinding(name);\n    }\n  }\n  function ResolveBinding(name) {\n    var env = getRunningContext().LexicalEnvironment;\n    return GetIdentifierReference(env, name);\n  }\n  function GetIdentifierReference(env, name) {\n    return !!env && (env.HasBinding(name) || GetIdentifierReference(env.OuterEnv, name));\n  }\n  function BlockDeclarationInstantiation(code, env) {\n    var declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    BoundNamesInstantiation(declarations, env);\n  }\n  function CallFunction(closure, parent) {\n    PrepareOrdinaryCall(closure);\n    FunctionDeclarationInstantiation(closure, parent);\n    Evaluate(closure.ECMAScriptCode, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: closure.Function,\n      key: \"body\"\n    }).concat(closure.Function.body.type === \"BlockStatement\" ? {\n      node: closure.Function.body,\n      key: \"body\"\n    } : []));\n    analysisContextStack.pop();\n  }\n  function PrepareOrdinaryCall(F) {\n    var calleeContext = new AnalysisContext();\n    var localEnv = new AnalysisEnvironment(F.Environment);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    analysisContextStack.push(calleeContext);\n  }\n  function FunctionDeclarationInstantiation(func, parent) {\n    var calleeContext = getRunningContext();\n    var code = func.ECMAScriptCode;\n    var formals = func.FormalParameters;\n    var hasParameterExpressions = containsExpression(formals);\n    var varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    var varNames = collectBoundNames(varDeclarations);\n    var env = calleeContext.LexicalEnvironment;\n    BoundNamesInstantiation(formals, env);\n    Evaluate(formals, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: func.Function,\n      key: \"params\"\n    }));\n    var varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      for (var n of varNames) {\n        env.CreateBinding(n);\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new AnalysisEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      for (var _n of varNames) {\n        varEnv.CreateBinding(_n);\n      }\n    }\n    var lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    var lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    BoundNamesInstantiation(lexDeclarations, lexEnv);\n  }\n  function InstantiateOrdinaryFunctionExpression(functionExpression) {\n    var scope = getRunningContext().LexicalEnvironment;\n    if (!functionExpression.id) {\n      return OrdinaryFunctionCreate(functionExpression, scope);\n    }\n    var name = functionExpression.id.name;\n    var funcEnv = new AnalysisEnvironment(scope);\n    funcEnv.CreateBinding(name);\n    return OrdinaryFunctionCreate(functionExpression, funcEnv);\n  }\n  function OrdinaryFunctionCreate(func, scope) {\n    return {\n      Function: func,\n      FormalParameters: func.params,\n      ECMAScriptCode: func.body.type === \"BlockStatement\" ? func.body.body : func.body,\n      Environment: scope\n    };\n  }\n  Evaluate(rootAst, withParent ? [] : undefined);\n  return attemptToVisitGlobals;\n}\n//# sourceMappingURL=precook.js.map","export function hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n//# sourceMappingURL=hasOwnProperty.js.map","import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"typescript\"];\nimport { parseAsEstree } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nexport function precookFunction(source) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    {\n      typescript\n    } = _ref,\n    restOptions = _objectWithoutProperties(_ref, _excluded);\n  var func = parseAsEstree(source, {\n    typescript\n  });\n  var attemptToVisitGlobals = precook(func, restOptions);\n  return {\n    function: func,\n    attemptToVisitGlobals\n  };\n}\n//# sourceMappingURL=precookFunction.js.map","import { parse, parseExpression } from \"@babel/parser\";\nexport function parseAsEstreeExpression(source) {\n  return parseExpression(source, {\n    plugins: [\"estree\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }]],\n    attachComment: false\n  });\n}\nexport function parseAsEstree(source) {\n  var {\n    typescript\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var file = parse(source, {\n    plugins: [\"estree\", typescript && \"typescript\"].filter(Boolean),\n    strictMode: true,\n    attachComment: false\n  });\n  var body = file.program.body;\n  var jsNodes = typescript ? [] : body;\n  if (typescript) {\n    for (var node of body) {\n      if (node.type.startsWith(\"TS\")) {\n        if (/Enum|Import|Export/.test(node.type)) {\n          throw new SyntaxError(\"Unsupported TypeScript syntax: \".concat(node.type));\n        }\n      } else {\n        jsNodes.push(node);\n      }\n    }\n  }\n  if (jsNodes.length === 0) {\n    throw new SyntaxError(\"Function declaration not found\");\n  }\n  if (jsNodes.length > 1 || jsNodes[0].type !== \"FunctionDeclaration\") {\n    throw new SyntaxError(\"Expect a single function declaration at top level, but received: \".concat(jsNodes.map(node => \"\\\"\".concat(node.type, \"\\\"\")).join(\", \")));\n  }\n  return jsNodes[0];\n}\n//# sourceMappingURL=parse.js.map","import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport { parseAsEstreeExpression } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\n// `raw` should always be asserted by `isEvaluable`.\nexport function preevaluate(raw, options) {\n  var fixes = [];\n  var source = raw.replace(/^\\s*<%[~=]?\\s|\\s%>\\s*$/g, m => {\n    fixes.push(m);\n    return \"\";\n  });\n  var expression = parseAsEstreeExpression(source);\n  var attemptToVisitGlobals = precook(expression, _objectSpread(_objectSpread({}, options), {}, {\n    expressionOnly: true\n  }));\n  return {\n    expression,\n    attemptToVisitGlobals,\n    source,\n    prefix: fixes[0],\n    suffix: fixes[1]\n  };\n}\nexport function isEvaluable(raw) {\n  return /^\\s*<%[~=]?\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function shouldAllowRecursiveEvaluations(raw) {\n  return /^\\s*<%~\\s/.test(raw);\n}\nexport function isTrackAll(raw) {\n  return /^\\s*<%=\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\n//# sourceMappingURL=preevaluate.js.map"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","e","r","t","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","_objectWithoutProperties","source","excluded","i","target","sourceKeys","indexOf","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_toPropertyKey","arg","input","hint","prim","Symbol","toPrimitive","undefined","res","TypeError","String","_typeof","iterator","constructor","ExecutionContext","this","EnvironmentRecord","outer","Map","OuterEnv","HasBinding","name","bindingMap","has","CreateMutableBinding","deletable","set","mutable","NormalCompletion","CreateImmutableBinding","strict","InitializeBinding","binding","get","assign","initialized","SetMutableBinding","ReferenceError","concat","GetBindingValue","DeclarativeEnvironment","FunctionEnvironment","SourceNode","for","FormalParameters","ECMAScriptCode","Environment","IsConstructor","ReferenceRecord","base","referenceName","Base","ReferenceName","Strict","CompletionRecord","type","Type","Value","Empty","collectBoundNames","root","names","Set","collect","node","Array","isArray","n","add","declarations","id","elements","left","properties","argument","from","containsExpression","some","computed","collectScopedDeclarations","options","nextOptions","var","Number","topLevel","kind","consequent","body","alternate","init","cases","block","handler","finalizer","IsPropertyReference","V","InitializeReferencedBinding","W","CopyDataProperties","excludedItems","getOwnPropertyNames","nextKey","desc","ForDeclarationBindingInstantiation","forDeclaration","env","isConst","LoopContinues","completion","UpdateEmpty","GetValue","ToPropertyKey","GetV","P","PutValue","CreateListIteratorRecord","args","cooked","RequireObjectCoercible","GetIdentifierReference","ApplyStringOrNumericBinaryOperator","leftValue","operator","rightValue","SyntaxError","reservedObjects","WeakSet","Function","self","window","global","Error","getGlobal","sanitize","allowedConstructors","URLSearchParams","WeakMap","RegExp","cook","rootAst","codeSource","_hooks$beforeEvaluate3","rules","globalVariables","hooks","expressionOnly","rootEnv","rootContext","VariableEnvironment","LexicalEnvironment","executionContextStack","entries","TemplateMap","Evaluate","optionalChainRef","_hooks$beforeEvaluate","_hooks$beforeBranch","_hooks$beforeBranch2","beforeEvaluate","array","element","spreadValues","ThrowIfFunctionIsInvalid","OrdinaryFunctionCreate","getRunningContext","rightRef","right","funcName","substring","start","end","thisValue","ref","callee","func","optional","skipped","EvaluateCall","expression","test","ResolveBinding","regex","raw","flags","includes","_leftValue","baseValue","object","_result","propertyKey","EvaluatePropertyAccessWithExpressionKey","property","identifier","propertyNameString","EvaluatePropertyAccessWithIdentifierKey","constructExpr","argList","ArgumentListEvaluation","constructorName","Date","isAllowedConstructor","_constructorName","EvaluateNew","prop","propName","EvaluateComputedPropertyName","_result2","expr","expressions","chunks","quasis","index","_expr","val","join","tagRef","tag","tagFunc","quasi","_ref","ApplyUnaryOperator","_lref","_rval","_rval2","DestructuringAssignmentEvaluation","lref","lval","rval","substr","ApplyStringOrNumericAssignment","oldEnv","blockEnv","BlockDeclarationInstantiation","blockValue","EvaluateStatementList","EvaluateBreakableStatement","stmtResult","DoWhileLoopEvaluation","lhs","lhsKind","uninitializedBoundNames","iterationKind","keyResult","runningContext","newEnv","exprRef","exprValue","_iterator","_key","EnumerateObjectProperties","ForInOfHeadEvaluation","stmt","iteratorRecord","destructuring","done","nextValue","next","lhsRef","iterationEnv","lhsName","BindingInitialization","result","status","return","innerResult","ForInOfBodyEvaluation","ForInOfLoopEvaluation","_node$init","ForBodyEvaluation","update","loopEnv","boundNames","dn","perIterationLets","bodyResult","ForLoopEvaluation","functionExpression","scope","funcEnv","closure","InstantiateOrdinaryFunctionExpression","beforeBranch","v","oldValue","newValue","prefix","switchValue","discriminant","_oldEnv","_blockEnv","R","defaultCaseIndex","findIndex","switchCase","hasDefaultCase","A","slice","found","C","CaseClauseIsSelected","_R2","foundInB","B","_C","_R3","_C2","_R4","CaseBlockEvaluation","_R","error","_hooks$beforeEvaluate2","thrownValue","param","catchEnv","argName","CatchClauseEvaluation","F","_result3","declarator","_lhs2","_value","_rval3","WhileLoopEvaluation","increment","perIterationBindings","CreatePerIterationEnvironment","lastIterationEnv","thisIterationEnv","bn","lastValue","pattern","excludedNames","valueTarget","KeyedDestructuringAssignmentEvaluation","RestDestructuringAssignmentEvaluation","PropertyDestructuringAssignmentEvaluation","assignmentTarget","isObjectOrArray","_value2","_done","_nextValue","IteratorDestructuringAssignmentEvaluation","propertyName","rhsValue","restProperty","code","d","IsConstantDeclaration","_fn","_fo","InstantiateFunctionObject","templateLiteral","memo","rawObj","map","template","freeze","GetTemplateObject","statements","s","sourceNode","isConstructor","_hooks$beforeCall","beforeCall","calleeContext","localEnv","PrepareForOrdinaryCall","formals","parameterNames","hasParameterExpressions","varDeclarations","varNames","functionNames","functionsToInitialize","_fn2","unshift","noVar","varEnv","paramName","IteratorBindingInitialization","_n","initialValue","lexEnv","lexDeclarations","_d","f","_fn3","_fo2","FunctionDeclarationInstantiation","EvaluateFunctionBody","OrdinaryCallEvaluateBody","pop","CallFunction","params","environment","InitializeBoundName","RestBindingInitialization","KeyedBindingInitialization","PropertyBindingInitialization","restObj","_node","_value3","_A","_n2","_done2","_value4","bindingElement","_done3","_value5","_lhs3","_v","_done4","_value6","_v2","async","generator","fn","fo","AnalysisContext","AnalysisEnvironment","bindingSet","CreateBinding","precook","visitors","withParent","attemptToVisitGlobals","analysisContextStack","EvaluateChildren","parent","_hooks$beforeVisit","_hooks$beforeVisitUnk","beforeVisit","hasOwnProperty","visit","_hooks$beforeVisitGlo","beforeVisitGlobal","_runningContext","BoundNamesInstantiation","lexicalBinding","_runningContext2","_oldEnv2","_lexicalBinding","_runningContext3","_oldEnv3","_env","_runningContext4","_oldEnv4","beforeVisitUnknown","console","warn","_excluded","precookFunction","typescript","restOptions","parse","plugins","Boolean","strictMode","attachComment","program","jsNodes","startsWith","parseAsEstree","function","preevaluate","fixes","replace","m","parseExpression","proposal","parseAsEstreeExpression","suffix","isEvaluable","shouldAllowRecursiveEvaluations","isTrackAll"],"sourceRoot":""}