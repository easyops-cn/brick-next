{"version":3,"file":"chunks/1122.b565ad1d.js","mappings":"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","sources":["webpack:///../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack:///../../node_modules/@next-core/cook/dist/esm/ExecutionContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/traverse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/context-free.js","webpack:///../../node_modules/@next-core/cook/dist/esm/sanitize.js","webpack:///../../node_modules/@next-core/cook/dist/esm/cook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/AnalysisContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/hasOwnProperty.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precookFunction.js","webpack:///../../node_modules/@next-core/cook/dist/esm/parse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/preevaluate.js"],"sourcesContent":["import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}","import _typeof from \"./typeof.js\";\nexport default function toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nexport let Mode = /*#__PURE__*/function (Mode) {\n  Mode[Mode[\"LEXICAL\"] = 0] = \"LEXICAL\";\n  Mode[Mode[\"STRICT\"] = 1] = \"STRICT\";\n  return Mode;\n}({});\nexport const SourceNode = Symbol.for(\"SourceNode\");\nexport const FormalParameters = Symbol.for(\"FormalParameters\");\nexport const ECMAScriptCode = Symbol.for(\"ECMAScriptCode\");\nexport const Environment = Symbol.for(\"Environment\");\nexport const IsConstructor = Symbol.for(\"IsConstructor\");\nexport const ThisMode = Symbol.for(\"ThisMode\");\nexport const DebuggerCall = Symbol.for(\"$DebuggerCall$\");\nexport const DebuggerScope = Symbol.for(\"$DebuggerScope$\");\nexport const DebuggerNode = Symbol.for(\"$DebuggerNode$\");\nexport const DebuggerReturn = Symbol.for(\"$DebuggerReturn$\");\n\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class ExecutionContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n    _defineProperty(this, \"Function\", void 0);\n  }\n}\nexport let BindingStatus = /*#__PURE__*/function (BindingStatus) {\n  BindingStatus[BindingStatus[\"UNINITIALIZED\"] = 0] = \"UNINITIALIZED\";\n  BindingStatus[BindingStatus[\"LEXICAL\"] = 1] = \"LEXICAL\";\n  BindingStatus[BindingStatus[\"INITIALIZED\"] = 2] = \"INITIALIZED\";\n  return BindingStatus;\n}({});\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class EnvironmentRecord {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingMap\", new Map());\n    _defineProperty(this, \"ThisValue\", undefined);\n    _defineProperty(this, \"ThisBindingStatus\", void 0);\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingMap.has(name);\n  }\n  CreateMutableBinding(name, deletable) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      mutable: true,\n      deletable\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Create an immutable binding.\n   *\n   * @param name - The binding name.\n   * @param strict - For named function expressions, strict is false, otherwise it's true.\n   * @returns CompletionRecord.\n   */\n  CreateImmutableBinding(name, strict) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      strict\n    });\n    return NormalCompletion(undefined);\n  }\n  InitializeBinding(name, value) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists and uninitialized.\n    Object.assign(binding, {\n      initialized: true,\n      value\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Update a mutable binding value, including function declarations.\n   *\n   * @param name - The binding name.\n   * @param value - The binding value.\n   * @param strict - For functions, strict is always false, otherwise it depends on strict-mode.\n   * @returns\n   */\n  SetMutableBinding(name, value, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    } else if (binding.mutable) {\n      binding.value = value;\n    } else {\n      throw new TypeError(`Assignment to constant variable`);\n    }\n    return NormalCompletion(undefined);\n  }\n  GetBindingValue(name, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    }\n    return binding.value;\n  }\n  HasThisBinding() {\n    return false;\n  }\n}\nexport class DeclarativeEnvironment extends EnvironmentRecord {}\nexport class FunctionEnvironment extends EnvironmentRecord {\n  constructor(F) {\n    super(F[Environment]);\n    if (F[ThisMode] === Mode.LEXICAL) {\n      this.ThisBindingStatus = BindingStatus.LEXICAL;\n    } else {\n      this.ThisBindingStatus = BindingStatus.UNINITIALIZED;\n    }\n  }\n  HasThisBinding() {\n    return this.ThisBindingStatus !== BindingStatus.LEXICAL;\n  }\n  BindThisValue(value) {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.INITIALIZED) {\n      throw new Error(\"This binding has been initialized\");\n    }\n    this.ThisValue = value;\n    this.ThisBindingStatus = BindingStatus.INITIALIZED;\n  }\n  GetThisBinding() {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.UNINITIALIZED) {\n      throw new Error(\"This binding is not initialized\");\n    }\n    return this.ThisValue;\n  }\n}\n// https://tc39.es/ecma262/#sec-reference-record-specification-type\nexport class ReferenceRecord {\n  constructor(base, referenceName, strict) {\n    _defineProperty(this, \"Base\", void 0);\n    _defineProperty(this, \"ReferenceName\", void 0);\n    /** Whether the reference is in strict mode. */\n    _defineProperty(this, \"Strict\", void 0);\n    this.Base = base;\n    this.ReferenceName = referenceName;\n    this.Strict = strict;\n  }\n}\n\n// https://tc39.es/ecma262/#sec-completion-record-specification-type\nexport class CompletionRecord {\n  constructor(type, value) {\n    _defineProperty(this, \"Type\", void 0);\n    _defineProperty(this, \"Value\", void 0);\n    this.Type = type;\n    this.Value = value;\n  }\n}\n// https://tc39.es/ecma262/#sec-normalcompletion\nexport function NormalCompletion(value) {\n  return new CompletionRecord(\"normal\", value);\n}\nexport const Empty = Symbol(\"empty completion\");\n//# sourceMappingURL=ExecutionContext.js.map","export function collectBoundNames(root) {\n  const names = new Set();\n  const collect = node => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"Identifier\":\n          names.add(node.name);\n          return;\n        case \"VariableDeclaration\":\n          return collect(node.declarations);\n        case \"VariableDeclarator\":\n          return collect(node.id);\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return collect(node.left);\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n        case \"FunctionDeclaration\":\n          return collect(node.id);\n      }\n    }\n  };\n  collect(root);\n  return Array.from(names);\n}\nexport function containsExpression(root) {\n  const collect = node => {\n    if (Array.isArray(node)) {\n      return node.some(collect);\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return true;\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return node.computed || collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n      }\n    }\n  };\n  return collect(root);\n}\nexport function collectScopedDeclarations(root, options) {\n  const declarations = [];\n  const nextOptions = {\n    var: options.var\n  };\n  const collect = (node, options) => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n, options);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"FunctionDeclaration\":\n          // At the top level of a function, or script, function declarations are\n          // treated like var declarations rather than like lexical declarations.\n          // See https://tc39.es/ecma262/#sec-static-semantics-toplevellexicallydeclarednames\n          if (Number(!options.var) ^ Number(options.topLevel)) {\n            declarations.push(node);\n          }\n          return;\n        case \"VariableDeclaration\":\n          if (Number(!options.var) ^ Number(node.kind === \"var\")) {\n            declarations.push(node);\n          }\n          return;\n        case \"SwitchCase\":\n          collect(node.consequent, nextOptions);\n          return;\n        case \"CatchClause\":\n          collect(node.body, nextOptions);\n          return;\n      }\n      if (options.var) {\n        switch (node.type) {\n          case \"BlockStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"IfStatement\":\n            collect(node.consequent, nextOptions);\n            collect(node.alternate, nextOptions);\n            return;\n          case \"DoWhileStatement\":\n          case \"WhileStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"ForStatement\":\n            collect(node.init, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            collect(node.left, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"SwitchStatement\":\n            collect(node.cases, nextOptions);\n            return;\n          case \"TryStatement\":\n            collect(node.block, nextOptions);\n            collect(node.handler, nextOptions);\n            collect(node.finalizer, nextOptions);\n            return;\n        }\n      }\n    }\n  };\n  collect(root, options);\n  return declarations;\n}\n//# sourceMappingURL=traverse.js.map","import { CompletionRecord, Empty, EnvironmentRecord, NormalCompletion, ReferenceRecord } from \"./ExecutionContext.js\";\nimport { collectBoundNames } from \"./traverse.js\";\n\n// https://tc39.es/ecma262/#sec-ispropertyreference\nexport function IsPropertyReference(V) {\n  return V.Base !== \"unresolvable\" && !(V.Base instanceof EnvironmentRecord);\n}\n\n// https://tc39.es/ecma262/#sec-initializereferencedbinding\nexport function InitializeReferencedBinding(V, W) {\n  const base = V.Base;\n  return base.InitializeBinding(V.ReferenceName, W);\n}\n\n// https://tc39.es/ecma262/#sec-copydataproperties\nexport function CopyDataProperties(target, source, excludedItems) {\n  if (source === undefined || source === null) {\n    return target;\n  }\n  const keys = Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source));\n  for (const nextKey of keys) {\n    if (!excludedItems.has(nextKey)) {\n      const desc = Object.getOwnPropertyDescriptor(source, nextKey);\n      if (desc !== null && desc !== void 0 && desc.enumerable) {\n        target[nextKey] = source[nextKey];\n      }\n    }\n  }\n  return target;\n}\n\n// https://tc39.es/ecma262/#sec-runtime-semantics-fordeclarationbindinginstantiation\nexport function ForDeclarationBindingInstantiation(forDeclaration, env) {\n  const isConst = forDeclaration.kind === \"const\";\n  for (const name of collectBoundNames(forDeclaration)) {\n    if (isConst) {\n      env.CreateImmutableBinding(name, true);\n    } else {\n      env.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// https://tc39.es/ecma262/#sec-loopcontinues\nexport function LoopContinues(completion) {\n  return completion.Type === \"normal\" || completion.Type == \"continue\";\n}\n\n// https://tc39.es/ecma262/#sec-updateempty\nexport function UpdateEmpty(completion, value) {\n  if (completion.Value !== Empty) {\n    return completion;\n  }\n  return new CompletionRecord(completion.Type, value);\n}\n\n// https://tc39.es/ecma262/#sec-getvalue\nexport function GetValue(V) {\n  if (V instanceof CompletionRecord) {\n    // Assert: V.Type is normal.\n    V = V.Value;\n  }\n  if (!(V instanceof ReferenceRecord)) {\n    return V;\n  }\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    const base = V.Base;\n    return base.GetBindingValue(V.ReferenceName, V.Strict);\n  }\n  return V.Base[V.ReferenceName];\n}\n\n// https://tc39.es/ecma262/#sec-topropertykey\nexport function ToPropertyKey(arg) {\n  if (typeof arg === \"symbol\") {\n    return arg;\n  }\n  return String(arg);\n}\n\n// https://tc39.es/ecma262/#sec-getv\nexport function GetV(V, P) {\n  return V[P];\n}\n\n// https://tc39.es/ecma262/#sec-putvalue\nexport function PutValue(V, W) {\n  // Assert: V is a ReferenceRecord.\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    return V.Base.SetMutableBinding(V.ReferenceName, W, V.Strict);\n  }\n  V.Base[V.ReferenceName] = W;\n  return NormalCompletion(undefined);\n}\n\n// https://tc39.es/ecma262/#sec-createlistiteratorRecord\nexport function CreateListIteratorRecord(args) {\n  if (!isIterable(args)) {\n    throw new TypeError(`${typeof args} is not iterable`);\n  }\n  return args[Symbol.iterator]();\n}\n\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nexport function RequireObjectCoercible(arg) {\n  if (arg === null || arg === undefined) {\n    throw new TypeError(\"Cannot destructure properties of undefined or null\");\n  }\n}\n\n// https://tc39.es/ecma262/#sec-getidentifierreference\nexport function GetIdentifierReference(env, name, strict) {\n  if (!env) {\n    return new ReferenceRecord(\"unresolvable\", name, strict);\n  }\n  if (env.HasBinding(name)) {\n    return new ReferenceRecord(env, name, strict);\n  }\n  return GetIdentifierReference(env.OuterEnv, name, strict);\n}\n\n// https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator\nexport function ApplyStringOrNumericBinaryOperator(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+\":\n      return leftValue + rightValue;\n    case \"-\":\n      return leftValue - rightValue;\n    case \"/\":\n      return leftValue / rightValue;\n    case \"%\":\n      return leftValue % rightValue;\n    case \"*\":\n      return leftValue * rightValue;\n    case \"**\":\n      return leftValue ** rightValue;\n    case \"==\":\n      return leftValue == rightValue;\n    case \"===\":\n      return leftValue === rightValue;\n    case \"!=\":\n      return leftValue != rightValue;\n    case \"!==\":\n      return leftValue !== rightValue;\n    case \">\":\n      return leftValue > rightValue;\n    case \"<\":\n      return leftValue < rightValue;\n    case \">=\":\n      return leftValue >= rightValue;\n    case \"<=\":\n      return leftValue <= rightValue;\n    case \"in\":\n      return leftValue in rightValue;\n  }\n  throw new SyntaxError(`Unsupported binary operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-assignment-operators\nexport function ApplyStringOrNumericAssignment(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+=\":\n    case \"-=\":\n    case \"*=\":\n    case \"/=\":\n    case \"%=\":\n    case \"**=\":\n      return ApplyStringOrNumericBinaryOperator(leftValue, operator.substr(0, operator.length - 1), rightValue);\n  }\n  throw new SyntaxError(`Unsupported assignment operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-unary-operators\nexport function ApplyUnaryOperator(target, operator) {\n  switch (operator) {\n    case \"!\":\n      return !target;\n    case \"+\":\n      return +target;\n    case \"-\":\n      return -target;\n    case \"void\":\n      return undefined;\n  }\n  throw new SyntaxError(`Unsupported unary operator \\`${operator}\\``);\n}\nexport function isIterable(cooked) {\n  if (Array.isArray(cooked)) {\n    return true;\n  }\n  if (cooked === null || cooked === undefined) {\n    return false;\n  }\n  return typeof cooked[Symbol.iterator] === \"function\";\n}\n//# sourceMappingURL=context-free.js.map","// Ref https://github.com/tc39/proposal-global\n// In addition, the es6-shim had to switch from Function('return this')()\n// due to CSP concerns, such that the current check to handle browsers,\n// node, web workers, and frames is:\n// istanbul ignore next\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getGlobal() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}\n\n/**\n * There are chances to construct a `Function` from a string, etc.\n * ```\n * ((a,b)=>a[b])(()=>1, 'constructor')('console.log(`yo`)')()\n * ```\n */\nconst reservedObjects = new WeakSet([\n// `Function(\"...\")` is considered *extremely vulnerable*.\nFunction,\n// `Object.assign()` is considered vulnerable.\nObject,\n// `prototype` is considered vulnerable.\nFunction.prototype, Object.prototype,\n// Global `window` is considered vulnerable, too.\ngetGlobal()]);\nexport function sanitize(cooked) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  if (reservedObjects.has(cooked)) {\n    throw new TypeError(\"Cannot access reserved objects such as `Function`.\");\n  }\n}\nconst allowedConstructors = new WeakSet([Array, Map, Set, URLSearchParams, WeakMap, WeakSet, RegExp]);\nexport function isAllowedConstructor(constructor) {\n  // `Date` maybe mocked when running tests for storyboard functions.\n  return allowedConstructors.has(constructor) || constructor === Date;\n}\n//# sourceMappingURL=sanitize.js.map","import { ApplyStringOrNumericAssignment, CreateListIteratorRecord, ApplyStringOrNumericBinaryOperator, GetV, GetValue, InitializeReferencedBinding, IsPropertyReference, LoopContinues, PutValue, RequireObjectCoercible, ToPropertyKey, UpdateEmpty, ApplyUnaryOperator, GetIdentifierReference, ForDeclarationBindingInstantiation, CopyDataProperties } from \"./context-free.js\";\nimport { CompletionRecord, DebuggerCall, DebuggerNode, DebuggerReturn, DebuggerScope, DeclarativeEnvironment, ECMAScriptCode, Empty, Environment, ExecutionContext, FormalParameters, FunctionEnvironment, IsConstructor, NormalCompletion, ReferenceRecord, SourceNode, Mode, ThisMode } from \"./ExecutionContext.js\";\nimport { sanitize, isAllowedConstructor } from \"./sanitize.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\nconst globalExecutionContextStack = [];\nexport function __dev_only_clearGlobalExecutionContextStack() {\n  globalExecutionContextStack.length = 0;\n}\nexport function __dev_only_getGlobalExecutionContextStack() {\n  return globalExecutionContextStack;\n}\n\n/** For next-core internal usage only. */\nexport function cook(rootAst, codeSource) {\n  var _hooks$beforeEvaluate4;\n  let {\n    rules,\n    debug,\n    externalSourceForDebug,\n    globalVariables = {},\n    // Allow debugger to override Array constructor.\n    ArrayConstructor = Array,\n    hooks = {}\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const expressionOnly = rootAst.type !== \"FunctionDeclaration\";\n  function doSanitize(cooked) {\n    if (!externalSourceForDebug) {\n      sanitize(cooked);\n    }\n  }\n  const rootEnv = new DeclarativeEnvironment(null);\n  const rootContext = new ExecutionContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  const executionContextStack = [rootContext];\n  for (const [key, value] of Object.entries(globalVariables)) {\n    rootEnv.CreateImmutableBinding(key, true);\n    rootEnv.InitializeBinding(key, value);\n  }\n  const TemplateMap = new WeakMap();\n\n  // https://tc39.es/ecma262/#sec-gettemplateobject\n  function GetTemplateObject(templateLiteral) {\n    const memo = TemplateMap.get(templateLiteral);\n    if (memo) {\n      return memo;\n    }\n    const rawObj = templateLiteral.quasis.map(quasi => quasi.value.raw);\n    const template = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n    Object.freeze(rawObj);\n    Object.defineProperty(template, \"raw\", {\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.freeze(template);\n    TemplateMap.set(templateLiteral, template);\n    return template;\n  }\n  let currentNode;\n  function* Evaluate(node, optionalChainRef, forceYield) {\n    var _hooks$beforeEvaluate, _hooks$beforeBranch2;\n    (_hooks$beforeEvaluate = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate === void 0 || _hooks$beforeEvaluate.call(hooks, node);\n    currentNode = node;\n    if (debug && (forceYield || node.type.endsWith(\"Statement\") && !(node.type === \"ExpressionStatement\" && (node.expression.type === \"CallExpression\" || node.expression.type === \"TaggedTemplateExpression\")) && node.type !== \"TryStatement\" && node.type !== \"BlockStatement\" && node.type !== \"DoWhileStatement\" && node.type !== \"WhileStatement\" && node.type !== \"ForStatement\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\")) {\n      yield;\n    }\n    // Expressions:\n    switch (node.type) {\n      case \"ArrayExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-array-initializer\n          const array = new ArrayConstructor();\n          for (const element of node.elements) {\n            if (!element) {\n              array.length += 1;\n            } else if (element.type === \"SpreadElement\") {\n              const spreadValues = GetValue(yield* Evaluate(element.argument));\n              array.push(...spreadValues);\n            } else {\n              array.push(GetValue(yield* Evaluate(element)));\n            }\n          }\n          return NormalCompletion(array);\n        }\n      case \"ArrowFunctionExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-arrow-function-definitions\n          ThrowIfFunctionIsInvalid(node);\n          const closure = InstantiateArrowFunctionExpression(node);\n          return NormalCompletion(closure);\n        }\n      case \"BinaryExpression\":\n        {\n          const leftRef = yield* Evaluate(node.left);\n          const leftValue = GetValue(leftRef);\n          const rightRef = yield* Evaluate(node.right);\n          const rightValue = GetValue(rightRef);\n          if (expressionOnly && node.operator === \"|>\") {\n            // Minimal pipeline operator is supported only in expression-only mode.\n            // See https://tc39.es/proposal-pipeline-operator\n            // and https://github.com/tc39/proposal-pipeline-operator\n            if (typeof rightValue !== \"function\") {\n              const funcName = codeSource.substring(node.right.start, node.right.end);\n              throw new TypeError(`${funcName} is not a function`);\n            }\n            let thisValue;\n            if (rightRef instanceof ReferenceRecord) {\n              if (IsPropertyReference(rightRef)) {\n                thisValue = rightRef.Base;\n              }\n            }\n            return NormalCompletion(rightValue.call(thisValue, leftValue));\n          }\n          // https://tc39.es/ecma262/#sec-additive-operators\n          const result = ApplyStringOrNumericBinaryOperator(leftValue, node.operator, rightValue);\n          return NormalCompletion(result);\n        }\n      case \"CallExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-function-calls\n          const ref = (yield* Evaluate(node.callee, optionalChainRef)).Value;\n          const func = GetValue(ref);\n          if ((func === undefined || func === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(func);\n          if (debug) yield;\n          return yield* EvaluateCall(func, ref, node.arguments, node.callee);\n        }\n      case \"ChainExpression\":\n        // https://tc39.es/ecma262/#sec-optional-chains\n        return yield* Evaluate(node.expression, {});\n      case \"ConditionalExpression\":\n        // https://tc39.es/ecma262/#sec-conditional-operator\n        return NormalCompletion(GetValue(yield* Evaluate(GetValue(yield* Evaluate(node.test)) ? node.consequent : node.alternate)));\n      case \"Identifier\":\n        // https://tc39.es/ecma262/#sec-identifiers\n        return NormalCompletion(ResolveBinding(node.name));\n      case \"Literal\":\n        {\n          // https://tc39.es/ecma262/#sec-primary-expression-literals\n          if (node.regex) {\n            if (node.value === null) {\n              // Invalid regular expression fails silently in @babel/parser.\n              throw new SyntaxError(`Invalid regular expression: ${node.raw}`);\n            }\n            if (node.regex.flags.includes(\"u\")) {\n              // Currently unicode flag is not fully supported across major browsers.\n              throw new SyntaxError(`Unsupported unicode flag in regular expression: ${node.raw}`);\n            }\n            // Always create a new RegExp, because the AST will be reused.\n            return NormalCompletion(new RegExp(node.regex.pattern, node.regex.flags));\n          }\n          return NormalCompletion(node.value);\n        }\n      case \"LogicalExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-binary-logical-operators\n          const leftValue = GetValue(yield* Evaluate(node.left));\n          switch (node.operator) {\n            case \"&&\":\n              return NormalCompletion(leftValue && GetValue(yield* Evaluate(node.right)));\n            case \"||\":\n              return NormalCompletion(leftValue || GetValue(yield* Evaluate(node.right)));\n            case \"??\":\n              return NormalCompletion(leftValue ?? GetValue(yield* Evaluate(node.right)));\n            // istanbul ignore next\n            default:\n              throw new SyntaxError(\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore never reach here.\n              `Unsupported logical operator '${node.operator}'`);\n          }\n        }\n      case \"MemberExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-property-accessors\n          const baseReference = (yield* Evaluate(node.object, optionalChainRef)).Value;\n          const baseValue = GetValue(baseReference);\n          if ((baseValue === undefined || baseValue === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(baseValue);\n          const result = node.computed ? yield* EvaluatePropertyAccessWithExpressionKey(baseValue, node.property, true) : EvaluatePropertyAccessWithIdentifierKey(baseValue, node.property, true);\n          doSanitize(result);\n          return NormalCompletion(result);\n        }\n      case \"NewExpression\":\n        // https://tc39.es/ecma262/#sec-new-operator\n        return yield* EvaluateNew(node.callee, node.arguments);\n      case \"ObjectExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-object-initializer\n          const object = {};\n          for (const prop of node.properties) {\n            if (prop.type === \"SpreadElement\") {\n              const fromValue = GetValue(yield* Evaluate(prop.argument));\n              CopyDataProperties(object, fromValue, new Set());\n            } else {\n              if (prop.kind !== \"init\") {\n                throw new SyntaxError(\"Unsupported object getter/setter\");\n              }\n              const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n              if (propName === \"__proto__\") {\n                throw new TypeError(\"Setting '__proto__' property is not allowed\");\n              }\n              const propValue = GetValue(yield* Evaluate(prop.value));\n              if (prop.method && typeof propValue === \"function\") {\n                SetFunctionName(propValue, propName);\n              }\n              object[propName] = propValue;\n            }\n          }\n          return NormalCompletion(object);\n        }\n      case \"SequenceExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-comma-operator\n          let result;\n          for (const expr of node.expressions) {\n            result = NormalCompletion(GetValue(yield* Evaluate(expr)));\n          }\n          return result;\n        }\n      case \"TemplateLiteral\":\n        {\n          // https://tc39.es/ecma262/#sec-template-literals\n          const chunks = [node.quasis[0].value.cooked];\n          let index = 0;\n          for (const expr of node.expressions) {\n            const val = GetValue(yield* Evaluate(expr));\n            chunks.push(String(val));\n            chunks.push(node.quasis[index += 1].value.cooked);\n          }\n          return NormalCompletion(chunks.join(\"\"));\n        }\n      case \"TaggedTemplateExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-tagged-templates\n          const tagRef = (yield* Evaluate(node.tag)).Value;\n          const tagFunc = GetValue(tagRef);\n          doSanitize(tagFunc);\n          if (debug) yield;\n          return yield* EvaluateCall(tagFunc, tagRef, node.quasi, node.tag);\n        }\n      case \"UnaryExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-unary-operators\n          const ref = (yield* Evaluate(node.argument)).Value;\n          if (!expressionOnly && node.operator === \"delete\") {\n            // Delete operator is supported only in function mode.\n            if (!(ref instanceof ReferenceRecord)) {\n              return NormalCompletion(true);\n            }\n            // istanbul ignore else\n            if (IsPropertyReference(ref)) {\n              const deleteStatus = delete ref.Base[ref.ReferenceName];\n              return NormalCompletion(deleteStatus);\n            }\n            // Should never reach here in strict mode.\n          }\n          if (node.operator === \"typeof\") {\n            if (ref instanceof ReferenceRecord && ref.Base === \"unresolvable\") {\n              return NormalCompletion(\"undefined\");\n            }\n            return NormalCompletion(typeof GetValue(ref));\n          }\n          return NormalCompletion(ApplyUnaryOperator(GetValue(ref), node.operator));\n        }\n    }\n    if (!expressionOnly) {\n      // Statements and assignments:\n      switch (node.type) {\n        case \"AssignmentExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-assignment-operators\n            if (node.operator === \"=\") {\n              if (!(node.left.type === \"ArrayPattern\" || node.left.type === \"ObjectPattern\")) {\n                const lref = (yield* Evaluate(node.left)).Value;\n                let rval;\n                if (IsAnonymousFunctionDefinition(node.right) && node.left.type === \"Identifier\") {\n                  rval = NamedEvaluation(node.right, node.left.name);\n                } else {\n                  const rref = yield* Evaluate(node.right);\n                  rval = GetValue(rref);\n                }\n                PutValue(lref, rval);\n                return NormalCompletion(rval);\n              }\n              const rref = yield* Evaluate(node.right);\n              const rval = GetValue(rref);\n              yield* DestructuringAssignmentEvaluation(node.left, rval);\n              return NormalCompletion(rval);\n            }\n            // Operators other than `=`.\n            const lref = (yield* Evaluate(node.left)).Value;\n            const lval = GetValue(lref);\n            const rref = yield* Evaluate(node.right);\n            const rval = GetValue(rref);\n            const r = ApplyStringOrNumericAssignment(lval, node.operator, rval);\n            PutValue(lref, r);\n            return NormalCompletion(r);\n          }\n        case \"BlockStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-block\n            if (!node.body.length) {\n              return NormalCompletion(Empty);\n            }\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.body, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const blockValue = yield* EvaluateStatementList(node.body);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return blockValue;\n          }\n        case \"BreakStatement\":\n          // https://tc39.es/ecma262/#sec-break-statement\n          return new CompletionRecord(\"break\", Empty);\n        case \"ContinueStatement\":\n          // https://tc39.es/ecma262/#sec-continue-statement\n          return new CompletionRecord(\"continue\", Empty);\n        case \"EmptyStatement\":\n          // https://tc39.es/ecma262/#sec-empty-statement\n          return NormalCompletion(Empty);\n        case \"DoWhileStatement\":\n          // https://tc39.es/ecma262/#sec-do-while-statement\n          return EvaluateBreakableStatement(yield* DoWhileLoopEvaluation(node));\n        case \"ExpressionStatement\":\n        case \"TSAsExpression\":\n          // https://tc39.es/ecma262/#sec-expression-statement\n          return yield* Evaluate(node.expression);\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n          // https://tc39.es/ecma262/#sec-for-in-and-for-of-statements\n          return EvaluateBreakableStatement(yield* ForInOfLoopEvaluation(node));\n        case \"ForStatement\":\n          // https://tc39.es/ecma262/#sec-for-statement\n          return EvaluateBreakableStatement(yield* ForLoopEvaluation(node));\n        case \"FunctionDeclaration\":\n          // https://tc39.es/ecma262/#sec-function-definitions\n          return NormalCompletion(Empty);\n        case \"FunctionExpression\":\n          // https://tc39.es/ecma262/#sec-function-defining-expressions\n          ThrowIfFunctionIsInvalid(node);\n          return NormalCompletion(InstantiateOrdinaryFunctionExpression(node));\n        case \"IfStatement\":\n          // https://tc39.es/ecma262/#sec-if-statement\n          if (GetValue(yield* Evaluate(node.test))) {\n            var _hooks$beforeBranch;\n            (_hooks$beforeBranch = hooks.beforeBranch) === null || _hooks$beforeBranch === void 0 || _hooks$beforeBranch.call(hooks, node, \"if\");\n            return UpdateEmpty(yield* Evaluate(node.consequent), undefined);\n          }\n          (_hooks$beforeBranch2 = hooks.beforeBranch) === null || _hooks$beforeBranch2 === void 0 || _hooks$beforeBranch2.call(hooks, node, \"else\");\n          if (node.alternate) {\n            return UpdateEmpty(yield* Evaluate(node.alternate), undefined);\n          }\n          return NormalCompletion(undefined);\n        case \"ReturnStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-return-statement\n            let v;\n            if (node.argument) {\n              const exprRef = yield* Evaluate(node.argument);\n              v = GetValue(exprRef);\n            }\n            return new CompletionRecord(\"return\", v);\n          }\n        case \"ThisExpression\":\n          {\n            if (!externalSourceForDebug) {\n              break;\n            }\n            const envRec = GetThisEnvironment();\n            return NormalCompletion(envRec.GetThisBinding());\n          }\n        case \"ThrowStatement\":\n          // https://tc39.es/ecma262/#sec-throw-statement\n          throw GetValue(yield* Evaluate(node.argument));\n        case \"UpdateExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-update-expressions\n            const lhs = (yield* Evaluate(node.argument)).Value;\n            const oldValue = Number(GetValue(lhs));\n            const newValue = node.operator === \"++\" ? oldValue + 1 : oldValue - 1;\n            PutValue(lhs, newValue);\n            return NormalCompletion(node.prefix ? newValue : oldValue);\n          }\n        case \"SwitchCase\":\n          return yield* EvaluateStatementList(node.consequent);\n        case \"SwitchStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-switch-statement\n            const exprRef = yield* Evaluate(node.discriminant);\n            const switchValue = GetValue(exprRef);\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.cases, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const R = yield* CaseBlockEvaluation(node.cases, switchValue);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return EvaluateBreakableStatement(R);\n          }\n        case \"TryStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-try-statement\n            let R;\n            try {\n              R = yield* Evaluate(node.block);\n            } catch (error) {\n              if (node.handler) {\n                var _hooks$beforeEvaluate2;\n                currentNode = node.handler;\n                (_hooks$beforeEvaluate2 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate2 === void 0 || _hooks$beforeEvaluate2.call(hooks, node.handler);\n                R = yield* CatchClauseEvaluation(node.handler, error);\n              } else {\n                throw error;\n              }\n            } finally {\n              if (node.finalizer) {\n                const F = yield* Evaluate(node.finalizer);\n                if (F.Type !== \"normal\") {\n                  R = F;\n                }\n              }\n            }\n            return R;\n          }\n        case \"VariableDeclaration\":\n          {\n            // https://tc39.es/ecma262/#sec-declarations-and-the-variable-statement\n            let result;\n            for (const declarator of node.declarations) {\n              currentNode = declarator;\n              if (!declarator.init) {\n                // Assert: a declarator without init is always an identifier.\n                if (node.kind === \"var\") {\n                  result = NormalCompletion(Empty);\n                } else {\n                  const lhs = ResolveBinding(declarator.id.name);\n                  result = InitializeReferencedBinding(lhs, undefined);\n                }\n              } else if (declarator.id.type === \"Identifier\") {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const bindingId = declarator.id.name;\n                const lhs = ResolveBinding(bindingId);\n                let value;\n                if (IsAnonymousFunctionDefinition(declarator.init)) {\n                  value = NamedEvaluation(declarator.init, bindingId);\n                } else {\n                  const rhs = yield* Evaluate(declarator.init);\n                  value = GetValue(rhs);\n                }\n                result = node.kind === \"var\" ? PutValue(lhs, value) : InitializeReferencedBinding(lhs, value);\n              } else {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const rhs = yield* Evaluate(declarator.init);\n                const rval = GetValue(rhs);\n                result = yield* BindingInitialization(declarator.id, rval, node.kind === \"var\" ? undefined : getRunningContext().LexicalEnvironment);\n              }\n            }\n            return result;\n          }\n        case \"WhileStatement\":\n          // https://tc39.es/ecma262/#sec-while-statement\n          return EvaluateBreakableStatement(yield* WhileLoopEvaluation(node));\n      }\n    }\n    // eslint-disable-next-line no-console\n    throw new SyntaxError(`Unsupported node type \\`${node.type}\\``);\n  }\n\n  // https://tc39.es/ecma262/#sec-execution-contexts\n  function getRunningContext() {\n    return executionContextStack[executionContextStack.length - 1];\n  }\n\n  // https://tc39.es/ecma262/#sec-resolvebinding\n  function ResolveBinding(name, env) {\n    if (!env) {\n      env = getRunningContext().LexicalEnvironment;\n    }\n    return GetIdentifierReference(env, name, true);\n  }\n\n  // Try statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation\n  function* CatchClauseEvaluation(node, thrownValue) {\n    if (!node.param) {\n      return yield* Evaluate(node.body);\n    }\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    const catchEnv = new DeclarativeEnvironment(oldEnv);\n    for (const argName of collectBoundNames(node.param)) {\n      catchEnv.CreateMutableBinding(argName, false);\n    }\n    getRunningContext().LexicalEnvironment = catchEnv;\n    yield* BindingInitialization(node.param, thrownValue, catchEnv);\n    const B = yield* Evaluate(node.body);\n    getRunningContext().LexicalEnvironment = oldEnv;\n    return B;\n  }\n\n  // Iteration statements and switch statements.\n  // https://tc39.es/ecma262/#prod-BreakableStatement\n  function EvaluateBreakableStatement(stmtResult) {\n    return stmtResult.Type === \"break\" ? stmtResult.Value === Empty ? NormalCompletion(undefined) : NormalCompletion(stmtResult.Value) : stmtResult;\n  }\n\n  // Switch statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  function* CaseBlockEvaluation(cases, input) {\n    let V;\n    const defaultCaseIndex = cases.findIndex(switchCase => !switchCase.test);\n    const hasDefaultCase = defaultCaseIndex >= 0;\n    const A = hasDefaultCase ? cases.slice(0, defaultCaseIndex) : cases;\n    let found = false;\n    for (const C of A) {\n      if (!found) {\n        found = yield* CaseClauseIsSelected(C, input);\n      }\n      if (found) {\n        const R = yield* Evaluate(C);\n        if (R.Value !== Empty) {\n          V = R.Value;\n        }\n        if (R.Type !== \"normal\") {\n          return UpdateEmpty(R, V);\n        }\n      }\n    }\n    if (!hasDefaultCase) {\n      return NormalCompletion(V);\n    }\n    let foundInB = false;\n    const B = cases.slice(defaultCaseIndex + 1);\n    if (!found) {\n      for (const C of B) {\n        if (!foundInB) {\n          foundInB = yield* CaseClauseIsSelected(C, input);\n        }\n        if (foundInB) {\n          const R = yield* Evaluate(C);\n          if (R.Value !== Empty) {\n            V = R.Value;\n          }\n          if (R.Type !== \"normal\") {\n            return UpdateEmpty(R, V);\n          }\n        }\n      }\n    }\n    if (foundInB) {\n      return NormalCompletion(V);\n    }\n    const R = yield* Evaluate(cases[defaultCaseIndex]);\n    if (R.Value !== Empty) {\n      V = R.Value;\n    }\n    if (R.Type !== \"normal\") {\n      return UpdateEmpty(R, V);\n    }\n\n    // NOTE: The following is another complete iteration of the second CaseClauses.\n    for (const C of B) {\n      const R = yield* Evaluate(C);\n      if (R.Value !== Empty) {\n        V = R.Value;\n      }\n      if (R.Type !== \"normal\") {\n        return UpdateEmpty(R, V);\n      }\n    }\n    return NormalCompletion(V);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected\n  function* CaseClauseIsSelected(C, input) {\n    const clauseSelector = GetValue(yield* Evaluate(C.test));\n    return input === clauseSelector;\n  }\n\n  // While statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-whileloopevaluation\n  function* WhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n    }\n  }\n\n  // Do-while Statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-dowhileloopevaluation\n  function* DoWhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n    }\n  }\n\n  // For in/of statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofloopevaluation\n  function* ForInOfLoopEvaluation(node) {\n    const lhs = node.left;\n    const isVariableDeclaration = lhs.type === \"VariableDeclaration\";\n    const lhsKind = isVariableDeclaration ? lhs.kind === \"var\" ? \"varBinding\" : \"lexicalBinding\" : \"assignment\";\n    const uninitializedBoundNames = lhsKind === \"lexicalBinding\" ? collectBoundNames(lhs) : [];\n    const iterationKind = node.type === \"ForInStatement\" ? \"enumerate\" : \"iterate\";\n    const keyResult = yield* ForInOfHeadEvaluation(uninitializedBoundNames, node.right, iterationKind);\n    if (keyResult.Type !== \"normal\") {\n      // When enumerate, if the target is nil, a break completion will be returned.\n      return keyResult;\n    }\n    return yield* ForInOfBodyEvaluation(lhs, node.body, keyResult.Value, iterationKind, lhsKind);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation\n  function* ForInOfHeadEvaluation(uninitializedBoundNames, expr, iterationKind) {\n    const runningContext = getRunningContext();\n    const oldEnv = runningContext.LexicalEnvironment;\n    if (uninitializedBoundNames.length > 0) {\n      const newEnv = new DeclarativeEnvironment(oldEnv);\n      for (const name of uninitializedBoundNames) {\n        newEnv.CreateMutableBinding(name, false);\n      }\n      runningContext.LexicalEnvironment = newEnv;\n    }\n    const exprRef = yield* Evaluate(expr, undefined, true);\n    runningContext.LexicalEnvironment = oldEnv;\n    const exprValue = GetValue(exprRef);\n    if (iterationKind === \"enumerate\") {\n      if (exprValue === null || exprValue === undefined) {\n        return new CompletionRecord(\"break\", Empty);\n      }\n      const iterator = EnumerateObjectProperties(exprValue);\n      return NormalCompletion(iterator);\n    }\n    const iterator = CreateListIteratorRecord(exprValue);\n    return NormalCompletion(iterator);\n  }\n  function* ForInOfBodyEvaluation(node, stmt, iteratorRecord, iterationKind, lhsKind) {\n    const lhs = lhsKind === \"assignment\" ? node : node.declarations[0].id;\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    let V;\n    // When `destructuring` is false,\n    // For `node` whose `kind` is assignment:\n    //   `lhs` is an `Identifier` or a `MemberExpression`,\n    // Otherwise:\n    //   `lhs` is an `Identifier`.\n    const destructuring = lhs.type === \"ObjectPattern\" || lhs.type === \"ArrayPattern\";\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      currentNode = lhs;\n      const {\n        done,\n        value: nextValue\n      } = iteratorRecord.next();\n      if (done) {\n        if (debug) yield;\n        return NormalCompletion(V);\n      }\n      let lhsRef;\n      let iterationEnv;\n      if (lhsKind === \"lexicalBinding\") {\n        iterationEnv = new DeclarativeEnvironment(oldEnv);\n        ForDeclarationBindingInstantiation(node, iterationEnv);\n        getRunningContext().LexicalEnvironment = iterationEnv;\n        if (debug) yield;\n        if (!destructuring) {\n          const [lhsName] = collectBoundNames(lhs);\n          lhsRef = ResolveBinding(lhsName);\n        }\n      } else {\n        if (debug) yield;\n        if (!destructuring) {\n          lhsRef = (yield* Evaluate(lhs)).Value;\n        }\n      }\n      destructuring ? lhsKind === \"assignment\" ? yield* DestructuringAssignmentEvaluation(lhs, nextValue) : lhsKind === \"varBinding\" ? yield* BindingInitialization(lhs, nextValue, undefined) : yield* BindingInitialization(lhs, nextValue, iterationEnv) : lhsKind === \"lexicalBinding\" ? InitializeReferencedBinding(lhsRef, nextValue) : PutValue(lhsRef, nextValue);\n      const result = yield* Evaluate(stmt);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      if (!LoopContinues(result)) {\n        const status = UpdateEmpty(result, V);\n        if (!(iterationKind === \"enumerate\" || iteratorRecord.return === undefined)) {\n          // Perform *IteratorClose*\n          // https://tc39.es/ecma262/#sec-iteratorclose\n          const innerResult = iteratorRecord.return();\n          if (!innerResult || ![\"object\", \"function\"].includes(typeof innerResult)) {\n            throw new TypeError(`Iterator result is not an object`);\n          }\n        }\n        return status;\n      }\n      if (result.Value !== Empty) {\n        V = result.Value;\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-enumerate-object-properties\n  function* EnumerateObjectProperties(value) {\n    for (const key in value) {\n      yield key;\n    }\n  }\n\n  // For statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forloopevaluation\n  function* ForLoopEvaluation(node) {\n    var _node$init;\n    if (((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\") {\n      // `for (var … ; … ; … ) …`\n      if (node.init.kind === \"var\") {\n        yield* Evaluate(node.init);\n        return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n      }\n      // `for (let/const … ; … ; … ) …`\n      const oldEnv = getRunningContext().LexicalEnvironment;\n      const loopEnv = new DeclarativeEnvironment(oldEnv);\n      const isConst = node.init.kind === \"const\";\n      const boundNames = collectBoundNames(node.init);\n      for (const dn of boundNames) {\n        if (isConst) {\n          loopEnv.CreateImmutableBinding(dn, true);\n        } else {\n          loopEnv.CreateMutableBinding(dn, false);\n        }\n      }\n      getRunningContext().LexicalEnvironment = loopEnv;\n      yield* Evaluate(node.init);\n      const perIterationLets = isConst ? [] : Array.from(boundNames);\n      const bodyResult = yield* ForBodyEvaluation(node.test, node.update, node.body, perIterationLets);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      return bodyResult;\n    }\n    // `for ( … ; … ; … ) …`\n    if (node.init) {\n      const exprRef = yield* Evaluate(node.init);\n      GetValue(exprRef);\n    }\n    return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n  }\n\n  // https://tc39.es/ecma262/#sec-forbodyevaluation\n  function* ForBodyEvaluation(test, increment, stmt, perIterationBindings) {\n    CreatePerIterationEnvironment(perIterationBindings);\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (test) {\n        const testRef = yield* Evaluate(test, undefined, true);\n        const testValue = GetValue(testRef);\n        if (!testValue) {\n          return NormalCompletion(V);\n        }\n      }\n      const result = yield* Evaluate(stmt);\n      if (!LoopContinues(result)) {\n        return UpdateEmpty(result, V);\n      }\n      if (result.Value) {\n        V = result.Value;\n      }\n      CreatePerIterationEnvironment(perIterationBindings);\n      if (increment) {\n        const incRef = yield* Evaluate(increment, undefined, true);\n        GetValue(incRef);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-createperiterationenvironment\n  function CreatePerIterationEnvironment(perIterationBindings) {\n    if (perIterationBindings.length === 0) {\n      return;\n    }\n    const lastIterationEnv = getRunningContext().LexicalEnvironment;\n    const outer = lastIterationEnv.OuterEnv;\n    const thisIterationEnv = new DeclarativeEnvironment(outer);\n    for (const bn of perIterationBindings) {\n      thisIterationEnv.CreateMutableBinding(bn, false);\n      const lastValue = lastIterationEnv.GetBindingValue(bn, false);\n      thisIterationEnv.InitializeBinding(bn, lastValue);\n    }\n    getRunningContext().LexicalEnvironment = thisIterationEnv;\n  }\n\n  // Destructuring assignments.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-destructuringassignmentevaluation\n  function* DestructuringAssignmentEvaluation(pattern, value) {\n    if (pattern.type === \"ObjectPattern\") {\n      RequireObjectCoercible(value);\n      if (pattern.properties.length > 0) {\n        yield* PropertyDestructuringAssignmentEvaluation(pattern.properties, value);\n      }\n      return NormalCompletion(Empty);\n    }\n    const iteratorRecord = CreateListIteratorRecord(value);\n    return yield* IteratorDestructuringAssignmentEvaluation(pattern.elements, iteratorRecord);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-propertydestructuringassignmentevaluation\n  function* PropertyDestructuringAssignmentEvaluation(properties, value) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"Property\") {\n        const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n        const valueTarget = prop.value.type === \"AssignmentPattern\" ? prop.value.left : prop.value;\n        if (valueTarget.type === \"Identifier\") {\n          const lref = ResolveBinding(valueTarget.name);\n          let v = GetV(value, propName);\n          if (prop.value.type === \"AssignmentPattern\" && v === undefined) {\n            if (IsAnonymousFunctionDefinition(prop.value.right)) {\n              v = NamedEvaluation(prop.value.right, valueTarget.name);\n            } else {\n              const defaultValue = yield* Evaluate(prop.value.right);\n              v = GetValue(defaultValue);\n            }\n          }\n          PutValue(lref, v);\n          excludedNames.add(propName);\n        } else {\n          yield* KeyedDestructuringAssignmentEvaluation(prop.value, value, propName);\n          excludedNames.add(propName);\n        }\n      } else {\n        yield* RestDestructuringAssignmentEvaluation(prop, value, excludedNames);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation\n  function* KeyedDestructuringAssignmentEvaluation(node, value, propertyName) {\n    const assignmentTarget = node.type === \"AssignmentPattern\" ? node.left : node;\n    const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n    let lref;\n    if (!isObjectOrArray) {\n      lref = (yield* Evaluate(assignmentTarget)).Value;\n    }\n    const v = GetV(value, propertyName);\n    let rhsValue;\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      // `assignmentTarget.type` is never \"Identifier\" here.\n      const defaultValue = yield* Evaluate(node.right);\n      rhsValue = GetValue(defaultValue);\n    } else {\n      rhsValue = v;\n    }\n    if (isObjectOrArray) {\n      return yield* DestructuringAssignmentEvaluation(assignmentTarget, rhsValue);\n    }\n    return PutValue(lref, rhsValue);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation\n  function* RestDestructuringAssignmentEvaluation(restProperty, value, excludedNames) {\n    const lref = (yield* Evaluate(restProperty.argument)).Value;\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    return PutValue(lref, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n  function* IteratorDestructuringAssignmentEvaluation(elements, iteratorRecord) {\n    let status = NormalCompletion(Empty);\n    for (const element of elements) {\n      if (!element) {\n        iteratorRecord.next();\n        status = NormalCompletion(Empty);\n        continue;\n      }\n      const assignmentTarget = element.type === \"RestElement\" ? element.argument : element.type === \"AssignmentPattern\" ? element.left : element;\n      const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n      let lref;\n      if (!isObjectOrArray) {\n        lref = (yield* Evaluate(assignmentTarget)).Value;\n      }\n      let v;\n      if (element.type !== \"RestElement\") {\n        const {\n          done,\n          value: nextValue\n        } = iteratorRecord.next();\n        const value = done ? undefined : nextValue;\n        if (element.type === \"AssignmentPattern\" && value === undefined) {\n          if (IsAnonymousFunctionDefinition(element.right) && assignmentTarget.type === \"Identifier\") {\n            v = NamedEvaluation(element.right, assignmentTarget.name);\n          } else {\n            const defaultValue = yield* Evaluate(element.right);\n            v = GetValue(defaultValue);\n          }\n        } else {\n          v = value;\n        }\n      } else {\n        // RestElement\n        v = new ArrayConstructor();\n        let n = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const {\n            done,\n            value: nextValue\n          } = iteratorRecord.next();\n          if (done) {\n            break;\n          }\n          v[n] = nextValue;\n          n++;\n        }\n      }\n      if (isObjectOrArray) {\n        status = yield* DestructuringAssignmentEvaluation(assignmentTarget, v);\n      } else {\n        status = PutValue(lref, v);\n      }\n    }\n    return status;\n  }\n\n  // Object expressions.\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key\n  function* EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {\n    const propertyNameReference = yield* Evaluate(expression);\n    const propertyNameValue = GetValue(propertyNameReference);\n    const propertyKey = ToPropertyKey(propertyNameValue);\n    return new ReferenceRecord(baseValue, propertyKey, strict);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key\n  function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifier, strict) {\n    currentNode = identifier;\n    const propertyNameString = identifier.name;\n    return new ReferenceRecord(baseValue, propertyNameString, strict);\n  }\n\n  // Block statements.\n  // https://tc39.es/ecma262/#sec-blockdeclarationinstantiation\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    for (const d of declarations) {\n      const IsConstantDeclaration = d.type === \"VariableDeclaration\" && d.kind === \"const\";\n      for (const dn of collectBoundNames(d)) {\n        if (IsConstantDeclaration) {\n          env.CreateImmutableBinding(dn, true);\n        } else {\n          env.CreateMutableBinding(dn, false);\n        }\n      }\n      if (d.type === \"FunctionDeclaration\") {\n        const [fn] = collectBoundNames(d);\n        const fo = InstantiateFunctionObject(d, env);\n        env.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // Function declarations and expressions.\n  // https://tc39.es/ecma262/#sec-evaluatecall\n  function* EvaluateCall(func, ref, args, callee) {\n    let thisValue;\n    if (ref instanceof ReferenceRecord) {\n      if (IsPropertyReference(ref)) {\n        thisValue = ref.Base;\n      }\n    }\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof func !== \"function\") {\n      const funcName = codeSource.substring(callee.start, callee.end);\n      throw new TypeError(`${funcName} is not a function`);\n    }\n    if (debug || externalSourceForDebug) {\n      const debuggerCall = func[DebuggerCall];\n      if (debuggerCall) {\n        const result = yield* debuggerCall.apply(thisValue, argList);\n        doSanitize(result);\n        return NormalCompletion(result);\n      }\n    }\n    const result = func.apply(thisValue, argList);\n    doSanitize(result);\n    return NormalCompletion(result);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluatenew\n  function* EvaluateNew(constructExpr, args) {\n    const ref = yield* Evaluate(constructExpr);\n    const constructor = GetValue(ref);\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof constructor !== \"function\" || constructor[IsConstructor] === false) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not a constructor`);\n    }\n    if (!externalSourceForDebug && !isAllowedConstructor(constructor) && constructor !== ArrayConstructor) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not an allowed constructor`);\n    }\n    return NormalCompletion(new constructor(...argList));\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-argumentlistevaluation\n  function* ArgumentListEvaluation(args) {\n    const array = [];\n    if (Array.isArray(args)) {\n      for (const arg of args) {\n        if (arg.type === \"SpreadElement\") {\n          const spreadValues = GetValue(yield* Evaluate(arg.argument));\n          array.push(...spreadValues);\n        } else {\n          array.push(GetValue(yield* Evaluate(arg)));\n        }\n      }\n    } else {\n      array.push(GetTemplateObject(args));\n      for (const expr of args.expressions) {\n        array.push(GetValue(yield* Evaluate(expr)));\n      }\n    }\n    return array;\n  }\n\n  // https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n  function* CallFunction(closure, thisArgument, args) {\n    var _hooks$beforeCall;\n    (_hooks$beforeCall = hooks.beforeCall) === null || _hooks$beforeCall === void 0 || _hooks$beforeCall.call(hooks, closure[SourceNode]);\n    const calleeContext = PrepareForOrdinaryCall(closure);\n    OrdinaryCallBindThis(closure, calleeContext, thisArgument);\n    const result = yield* OrdinaryCallEvaluateBody(closure, args);\n    if (debug) {\n      currentNode = {\n        ...closure[SourceNode],\n        [DebuggerReturn]: true\n      };\n      yield {\n        type: \"return\",\n        value: result.Type === \"return\" ? result.Value : undefined\n      };\n    }\n    executionContextStack.pop();\n    globalExecutionContextStack.pop();\n    if (result.Type === \"return\") {\n      return result.Value;\n    }\n    return undefined;\n  }\n\n  // https://tc39.es/ecma262/#sec-prepareforordinarycall\n  function PrepareForOrdinaryCall(F) {\n    const calleeContext = new ExecutionContext();\n    calleeContext.Function = F;\n    const localEnv = new FunctionEnvironment(F);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    executionContextStack.push(calleeContext);\n    globalExecutionContextStack.push(calleeContext);\n    return calleeContext;\n  }\n  function OrdinaryCallBindThis(F, calleeContext, thisArgument) {\n    if (F[ThisMode] === Mode.LEXICAL) {\n      return;\n    }\n    const localEnv = calleeContext.LexicalEnvironment;\n    localEnv === null || localEnv === void 0 || localEnv.BindThisValue(thisArgument);\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinarycallevaluatebody\n  function* OrdinaryCallEvaluateBody(F, args) {\n    return yield* EvaluateFunctionBody(F[ECMAScriptCode], F, args);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-evaluatefunctionbody\n  function* EvaluateFunctionBody(body, F, args) {\n    yield* FunctionDeclarationInstantiation(F, args);\n    if (Array.isArray(body)) {\n      return yield* EvaluateStatementList(body);\n    }\n    return new CompletionRecord(\"return\", GetValue(yield* Evaluate(body)));\n  }\n\n  // https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation\n  function* EvaluateStatementList(statements) {\n    let result = NormalCompletion(Empty);\n    for (const stmt of statements) {\n      const s = yield* Evaluate(stmt);\n      if (s.Type !== \"normal\") {\n        return s;\n      }\n      result = UpdateEmpty(result, s.Value);\n    }\n    return result;\n  }\n  function GetThisEnvironment() {\n    let env = getRunningContext().LexicalEnvironment;\n    while (env) {\n      if (env.HasThisBinding()) {\n        return env;\n      }\n      env = env.OuterEnv;\n    }\n    throw new Error(\"Accessing global this is forbidden\");\n  }\n\n  // https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition\n  function IsAnonymousFunctionDefinition(node) {\n    // No ParenthesizedExpression in ESTree.\n    return node.type === \"FunctionExpression\" && !node.id || node.type === \"ArrowFunctionExpression\";\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-namedevaluation\n  function NamedEvaluation(node, name) {\n    var _hooks$beforeEvaluate3;\n    (_hooks$beforeEvaluate3 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate3 === void 0 || _hooks$beforeEvaluate3.call(hooks, node);\n    // No ParenthesizedExpression in ESTree.\n    switch (node.type) {\n      case \"FunctionExpression\":\n        return InstantiateOrdinaryFunctionExpression(node, name);\n      case \"ArrowFunctionExpression\":\n        return InstantiateArrowFunctionExpression(node, name);\n      // istanbul ignore next: should never happen\n      default:\n        throw new Error(`Unexpected node type for NamedEvaluation: ${node.type}`);\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-functiondeclarationinstantiation\n  function* FunctionDeclarationInstantiation(func, args) {\n    const calleeContext = getRunningContext();\n    const code = func[ECMAScriptCode];\n    const formals = func[FormalParameters];\n    const parameterNames = collectBoundNames(formals);\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n\n    // `functionNames` ∈ `varNames`\n    // `functionsToInitialize` ≈ `functionNames`\n    const functionNames = [];\n    const functionsToInitialize = [];\n    for (let i = varDeclarations.length - 1; i >= 0; i--) {\n      const d = varDeclarations[i];\n      if (d.type === \"FunctionDeclaration\") {\n        ThrowIfFunctionIsInvalid(d);\n        const [fn] = collectBoundNames(d);\n        if (!functionNames.includes(fn)) {\n          functionNames.unshift(fn);\n          functionsToInitialize.unshift(d);\n        }\n      } else if (rules !== null && rules !== void 0 && rules.noVar) {\n        throw new SyntaxError(\"Var declaration is not recommended, use `let` or `const` instead\");\n      }\n    }\n\n    // let argumentsObjectNeeded = true;\n    // if (func[ThisMode] === Mode.LEXICAL) {\n    //   // NOTE: Arrow functions never have an arguments object.\n    //   argumentsObjectNeeded = false;\n    // } else if (parameterNames.includes(\"arguments\")) {\n    //   argumentsObjectNeeded = false;\n    // } else if (!hasParameterExpressions && (\n    //   varNames.includes(\"arguments\") ||\n    //   collectBoundNames(collectScopedDeclarations(code, { var: false })).includes(\"arguments\")\n    // )) {\n    //   argumentsObjectNeeded = false;\n    // }\n    // NOTE: In strict mode, no parameter/function/var/lexical names can be \"arguments\".\n    const argumentsObjectNeeded = !!externalSourceForDebug && func[ThisMode] !== Mode.LEXICAL;\n    const env = calleeContext.LexicalEnvironment;\n    for (const paramName of parameterNames) {\n      // In strict mode, it's guaranteed no duplicate params exist.\n      env.CreateMutableBinding(paramName, false);\n    }\n    let parameterBindings = parameterNames;\n    if (argumentsObjectNeeded) {\n      const ao = CreateUnmappedArgumentsObject(args);\n      env.CreateImmutableBinding(\"arguments\", false);\n      env.InitializeBinding(\"arguments\", ao);\n      parameterBindings = parameterNames.concat(\"arguments\");\n    }\n    const iteratorRecord = CreateListIteratorRecord(args);\n    yield* IteratorBindingInitialization(formals, iteratorRecord, env);\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      // `varNames` are unique.\n      const instantiatedVarNames = [...parameterBindings];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          env.CreateMutableBinding(n, false);\n          env.InitializeBinding(n, undefined);\n        }\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new DeclarativeEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      // `varNames` are unique.\n      const instantiatedVarNames = [];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          varEnv.CreateMutableBinding(n, false);\n          let initialValue;\n          if (parameterBindings.includes(n) && !functionNames.includes(n)) {\n            initialValue = env.GetBindingValue(n, false);\n          }\n          varEnv.InitializeBinding(n, initialValue);\n          // NOTE: A var with the same name as a formal parameter initially has\n          // the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    for (const d of lexDeclarations) {\n      for (const dn of collectBoundNames(d)) {\n        // Only lexical VariableDeclaration here in top-level.\n        if (d.kind === \"const\") {\n          lexEnv.CreateImmutableBinding(dn, true);\n        } else {\n          lexEnv.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n    for (const f of functionsToInitialize) {\n      const [fn] = collectBoundNames(f);\n      const fo = InstantiateFunctionObject(f, lexEnv);\n      varEnv.SetMutableBinding(fn, fo, false);\n    }\n  }\n  function CreateUnmappedArgumentsObject(args) {\n    const argList = [...args];\n    const argumentObject = {};\n    Object.defineProperty(argumentObject, \"length\", {\n      value: argList.length,\n      writable: true,\n      configurable: true\n    });\n    for (let index = 0; index < argList.length; index++) {\n      argumentObject[String(index)] = argList[index];\n    }\n    Object.defineProperty(argumentObject, Symbol.iterator, {\n      value: Array.prototype.values,\n      writable: true,\n      configurable: true\n    });\n    const ThrowTypeError = () => {\n      throw new TypeError(\"'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\");\n    };\n    Object.defineProperty(argumentObject, \"callee\", {\n      get: ThrowTypeError,\n      set: ThrowTypeError\n    });\n    return argumentObject;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatefunctionobject\n  function InstantiateFunctionObject(func, scope) {\n    const F = OrdinaryFunctionCreate(func, scope, true, false);\n    if (func.id) {\n      SetFunctionName(F, func.id.name);\n    }\n    return F;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression\n  function InstantiateOrdinaryFunctionExpression(functionExpression, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (functionExpression.id) {\n      const name = functionExpression.id.name;\n      const funcEnv = new DeclarativeEnvironment(scope);\n      funcEnv.CreateImmutableBinding(name, false);\n      const closure = OrdinaryFunctionCreate(functionExpression, funcEnv, true, false);\n      SetFunctionName(closure, name);\n      funcEnv.InitializeBinding(name, closure);\n      return closure;\n    } else {\n      const closure = OrdinaryFunctionCreate(functionExpression, scope, true, false);\n      SetFunctionName(closure, name ?? \"\");\n      return closure;\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression\n  function InstantiateArrowFunctionExpression(arrowFunction, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    const closure = OrdinaryFunctionCreate(arrowFunction, scope, false, true);\n    SetFunctionName(closure, name ?? \"\");\n    return closure;\n  }\n  function SetFunctionName(F, name) {\n    Object.defineProperty(F, \"name\", {\n      value: name,\n      configurable: true\n    });\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinaryfunctioncreate\n  function OrdinaryFunctionCreate(sourceNode, scope, isConstructor, lexicalThis) {\n    const F = function () {\n      // eslint-disable-next-line prefer-rest-params\n      return unwind(CallFunction(F, this, arguments));\n    };\n    Object.defineProperties(F, {\n      [SourceNode]: {\n        value: sourceNode\n      },\n      [FormalParameters]: {\n        value: sourceNode.params\n      },\n      [ECMAScriptCode]: {\n        value: sourceNode.body.type === \"BlockStatement\" ? sourceNode.body.body : sourceNode.body\n      },\n      [Environment]: {\n        value: scope\n      },\n      [IsConstructor]: {\n        value: isConstructor\n      },\n      [ThisMode]: {\n        value: lexicalThis ? Mode.LEXICAL : Mode.STRICT\n      }\n    });\n    const len = ExpectedArgumentCount(sourceNode.params);\n    Object.defineProperty(F, \"length\", {\n      configurable: true,\n      value: len\n    });\n    if (debug || externalSourceForDebug) {\n      Object.defineProperty(F, DebuggerCall, {\n        value: function () {\n          // eslint-disable-next-line prefer-rest-params\n          return CallFunction(F, this, arguments);\n        }\n      });\n    }\n    return F;\n  }\n  function ExpectedArgumentCount(params) {\n    let count = 0;\n    for (const param of params) {\n      switch (param.type) {\n        case \"AssignmentPattern\":\n        case \"RestElement\":\n          return count;\n        default:\n          count++;\n      }\n    }\n    return count;\n  }\n\n  // Patterns initialization.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization\n  function* BindingInitialization(node, value, environment) {\n    switch (node.type) {\n      case \"Identifier\":\n        return InitializeBoundName(node.name, value, environment);\n      case \"ObjectPattern\":\n        RequireObjectCoercible(value);\n        return yield* PropertyBindingInitialization(node.properties, value, environment);\n      case \"ArrayPattern\":\n        {\n          const iteratorRecord = CreateListIteratorRecord(value);\n          return yield* IteratorBindingInitialization(node.elements, iteratorRecord, environment);\n        }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  function* PropertyBindingInitialization(properties, value, environment) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"RestElement\") {\n        return RestBindingInitialization(prop, value, environment, excludedNames);\n      }\n      if (!prop.computed && prop.key.type === \"Identifier\") {\n        yield* KeyedBindingInitialization(prop.value, value, environment, prop.key.name);\n        excludedNames.add(prop.key.name);\n      } else {\n        const P = yield* EvaluateComputedPropertyName(prop.key);\n        yield* KeyedBindingInitialization(prop.value, value, environment, P);\n        excludedNames.add(P);\n      }\n    }\n    return NormalCompletion(Empty);\n  }\n\n  // https://tc39.es/ecma262/#prod-ComputedPropertyName\n  function* EvaluateComputedPropertyName(node) {\n    const propName = GetValue(yield* Evaluate(node));\n    return ToPropertyKey(propName);\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization\n  function RestBindingInitialization(restProperty, value, environment, excludedNames) {\n    const lhs = ResolveBinding(restProperty.argument.name, environment);\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    if (!environment) {\n      return PutValue(lhs, restObj);\n    }\n    return InitializeReferencedBinding(lhs, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization\n  function* IteratorBindingInitialization(elements, iteratorRecord, environment) {\n    if (elements.length === 0) {\n      return NormalCompletion(Empty);\n    }\n    let result;\n    for (const node of elements) {\n      if (!node) {\n        // Elision element.\n        iteratorRecord.next();\n        result = NormalCompletion(Empty);\n      } else if (node.type === \"RestElement\") {\n        // Rest element.\n        if (node.argument.type === \"Identifier\") {\n          const lhs = ResolveBinding(node.argument.name, environment);\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = environment ? InitializeReferencedBinding(lhs, A) : PutValue(lhs, A);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        } else {\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = yield* BindingInitialization(node.argument, A, environment);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        }\n      } else {\n        // Normal element.\n        const bindingElement = node.type === \"AssignmentPattern\" ? node.left : node;\n        switch (bindingElement.type) {\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n            {\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                const defaultValue = yield* Evaluate(node.right);\n                v = GetValue(defaultValue);\n              }\n              result = yield* BindingInitialization(bindingElement, v, environment);\n              break;\n            }\n          case \"Identifier\":\n            {\n              const bindingId = bindingElement.name;\n              const lhs = ResolveBinding(bindingId, environment);\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                if (IsAnonymousFunctionDefinition(node.right)) {\n                  v = NamedEvaluation(node.right, bindingId);\n                } else {\n                  const defaultValue = yield* Evaluate(node.right);\n                  v = GetValue(defaultValue);\n                }\n              }\n              result = environment ? InitializeReferencedBinding(lhs, v) : PutValue(lhs, v);\n              break;\n            }\n        }\n      }\n    }\n    return result;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization\n  function* KeyedBindingInitialization(node, value, environment, propertyName) {\n    const isIdentifier = node.type === \"Identifier\" || node.type === \"AssignmentPattern\" && node.left.type === \"Identifier\";\n    if (isIdentifier) {\n      const bindingId = node.type === \"Identifier\" ? node.name : node.left.name;\n      const lhs = ResolveBinding(bindingId, environment);\n      let v = GetV(value, propertyName);\n      if (node.type === \"AssignmentPattern\" && v === undefined) {\n        if (IsAnonymousFunctionDefinition(node.right)) {\n          v = NamedEvaluation(node.right, bindingId);\n        } else {\n          const defaultValue = yield* Evaluate(node.right);\n          v = GetValue(defaultValue);\n        }\n      }\n      if (!environment) {\n        return PutValue(lhs, v);\n      }\n      return InitializeReferencedBinding(lhs, v);\n    }\n    let v = GetV(value, propertyName);\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      const defaultValue = yield* Evaluate(node.right);\n      v = GetValue(defaultValue);\n    }\n    return yield* BindingInitialization(node.type === \"AssignmentPattern\" ? node.left : node, v, environment);\n  }\n\n  // https://tc39.es/ecma262/#sec-initializeboundname\n  function InitializeBoundName(name, value, environment) {\n    // Assert: environment is always present.\n    environment.InitializeBinding(name, value);\n    return NormalCompletion(Empty);\n  }\n  function ThrowIfFunctionIsInvalid(func) {\n    if (func.async || func.generator) {\n      throw new SyntaxError(`${func.async ? \"Async\" : \"Generator\"} function is not allowed`);\n    }\n    if (expressionOnly && !func.expression) {\n      throw new SyntaxError(\"Only an `Expression` is allowed in `ArrowFunctionExpression`'s body\");\n    }\n  }\n  if (expressionOnly) {\n    return GetValue(unwind(Evaluate(rootAst)));\n  }\n  (_hooks$beforeEvaluate4 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate4 === void 0 || _hooks$beforeEvaluate4.call(hooks, rootAst);\n  ThrowIfFunctionIsInvalid(rootAst);\n  const [fn] = collectBoundNames(rootAst);\n  // Create an immutable binding for the root function.\n  rootEnv.CreateImmutableBinding(fn, true);\n  const fo = InstantiateFunctionObject(rootAst, rootEnv);\n  rootEnv.InitializeBinding(fn, fo);\n  if (debug) {\n    Object.defineProperties(fo, {\n      [DebuggerScope]: {\n        value: function () {\n          return getRunningContext().LexicalEnvironment;\n        }\n      },\n      [DebuggerNode]: {\n        value: function () {\n          return currentNode;\n        }\n      }\n    });\n  }\n  return fo;\n}\nfunction unwind(iterator) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const {\n      done,\n      value\n    } = iterator.next();\n    if (done) {\n      return value;\n    }\n  }\n}\n//# sourceMappingURL=cook.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class AnalysisContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n  }\n}\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class AnalysisEnvironment {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingSet\", new Set());\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingSet.has(name);\n  }\n  CreateBinding(name) {\n    this.bindingSet.add(name);\n  }\n}\n//# sourceMappingURL=AnalysisContext.js.map","import { hasOwnProperty } from \"./hasOwnProperty.js\";\nimport { AnalysisContext, AnalysisEnvironment } from \"./AnalysisContext.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\n/**\n * Analysis an AST of a storyboard function or an evaluation expression.\n *\n * @param rootAst - The root AST.\n * @param options - Analysis options.\n * @returns A set of global variables the root AST attempts to access.\n */\nexport function precook(rootAst) {\n  let {\n    expressionOnly,\n    visitors,\n    withParent,\n    externalSourceForDebug,\n    hooks = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const attemptToVisitGlobals = new Set();\n  const analysisContextStack = [];\n  const rootEnv = new AnalysisEnvironment(null);\n  const rootContext = new AnalysisContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  analysisContextStack.push(rootContext);\n  function getRunningContext() {\n    return analysisContextStack[analysisContextStack.length - 1];\n  }\n  function visit(node) {\n    if (visitors && hasOwnProperty(visitors, node.type)) {\n      visitors[node.type](node);\n    }\n  }\n  function EvaluateChildren(node, keys, parent) {\n    for (const key of keys) {\n      Evaluate(node[key], parent === null || parent === void 0 ? void 0 : parent.concat({\n        node,\n        key\n      }));\n    }\n  }\n  function Evaluate(node, parent) {\n    if (Array.isArray(node)) {\n      node.forEach((n, index) => {\n        Evaluate(n, parent ? parent.slice(0, -1).concat({\n          ...parent[parent.length - 1],\n          index\n        }) : parent);\n      });\n    } else if (node) {\n      var _hooks$beforeVisit, _hooks$beforeVisitUnk;\n      // `node` maybe `null` in some cases.\n      (_hooks$beforeVisit = hooks.beforeVisit) === null || _hooks$beforeVisit === void 0 || _hooks$beforeVisit.call(hooks, node, parent);\n      visit(node);\n      // Expressions:\n      switch (node.type) {\n        case \"Identifier\":\n          if (!ResolveBinding(node.name)) {\n            var _hooks$beforeVisitGlo;\n            (_hooks$beforeVisitGlo = hooks.beforeVisitGlobal) === null || _hooks$beforeVisitGlo === void 0 || _hooks$beforeVisitGlo.call(hooks, node, parent);\n            attemptToVisitGlobals.add(node.name);\n          }\n          return;\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          EvaluateChildren(node, [\"elements\"], parent);\n          return;\n        case \"ArrowFunctionExpression\":\n          {\n            const env = getRunningContext().LexicalEnvironment;\n            const closure = OrdinaryFunctionCreate(node, env, true);\n            CallFunction(closure, parent);\n            return;\n          }\n        case \"AssignmentPattern\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          EvaluateChildren(node, [\"left\", \"right\"], parent);\n          return;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          EvaluateChildren(node, [\"callee\", \"arguments\"], parent);\n          return;\n        case \"ChainExpression\":\n          EvaluateChildren(node, [\"expression\"], parent);\n          return;\n        case \"ConditionalExpression\":\n          EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n          return;\n        case \"MemberExpression\":\n          EvaluateChildren(node, [\"object\"], parent);\n          if (node.computed) {\n            EvaluateChildren(node, [\"property\"], parent);\n          }\n          return;\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          EvaluateChildren(node, [\"properties\"], parent);\n          return;\n        case \"Property\":\n          if (node.computed) {\n            EvaluateChildren(node, [\"key\"], parent);\n          }\n          EvaluateChildren(node, [\"value\"], parent);\n          return;\n        case \"RestElement\":\n        case \"SpreadElement\":\n        case \"UnaryExpression\":\n          EvaluateChildren(node, [\"argument\"], parent);\n          return;\n        case \"SequenceExpression\":\n        case \"TemplateLiteral\":\n          EvaluateChildren(node, [\"expressions\"], parent);\n          return;\n        case \"TaggedTemplateExpression\":\n          EvaluateChildren(node, [\"tag\", \"quasi\"], parent);\n          return;\n        case \"Literal\":\n          return;\n      }\n      if (!expressionOnly) {\n        // Statements and assignments:\n        switch (node.type) {\n          case \"AssignmentExpression\":\n            EvaluateChildren(node, [\"right\", \"left\"], parent);\n            return;\n          case \"BlockStatement\":\n            {\n              if (!node.body.length) {\n                return;\n              }\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.body, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"BreakStatement\":\n          case \"ContinueStatement\":\n          case \"EmptyStatement\":\n            return;\n          case \"CatchClause\":\n            {\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const catchEnv = new AnalysisEnvironment(oldEnv);\n              BoundNamesInstantiation(node.param, catchEnv);\n              runningContext.LexicalEnvironment = catchEnv;\n              EvaluateChildren(node, [\"param\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"DoWhileStatement\":\n            EvaluateChildren(node, [\"body\", \"test\"], parent);\n            return;\n          case \"ExpressionStatement\":\n          case \"TSAsExpression\":\n            EvaluateChildren(node, [\"expression\"], parent);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            {\n              // ForIn/OfHeadEvaluation\n              const lexicalBinding = node.left.type === \"VariableDeclaration\" && node.left.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const newEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, newEnv);\n                runningContext.LexicalEnvironment = newEnv;\n              }\n              EvaluateChildren(node, [\"right\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n\n              // ForIn/OfBodyEvaluation\n              if (lexicalBinding) {\n                const iterationEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, iterationEnv);\n                runningContext.LexicalEnvironment = iterationEnv;\n              }\n              EvaluateChildren(node, [\"left\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ForStatement\":\n            {\n              var _node$init;\n              const lexicalBinding = ((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\" && node.init.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const loopEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.init, loopEnv);\n                runningContext.LexicalEnvironment = loopEnv;\n              }\n              EvaluateChildren(node, [\"init\", \"test\", \"body\", \"update\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"FunctionDeclaration\":\n            {\n              const [fn] = collectBoundNames(node);\n              const env = getRunningContext().LexicalEnvironment;\n              const fo = OrdinaryFunctionCreate(node, env);\n              env.CreateBinding(fn);\n              CallFunction(fo, parent);\n              return;\n            }\n          case \"FunctionExpression\":\n            {\n              const closure = InstantiateOrdinaryFunctionExpression(node);\n              CallFunction(closure, parent);\n              return;\n            }\n          case \"IfStatement\":\n            EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n            return;\n          case \"ReturnStatement\":\n          case \"ThrowStatement\":\n          case \"UpdateExpression\":\n            EvaluateChildren(node, [\"argument\"], parent);\n            return;\n          case \"SwitchCase\":\n            EvaluateChildren(node, [\"test\", \"consequent\"], parent);\n            return;\n          case \"SwitchStatement\":\n            {\n              EvaluateChildren(node, [\"discriminant\"], parent);\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.cases, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"cases\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ThisExpression\":\n            {\n              if (!externalSourceForDebug) {\n                break;\n              }\n              return;\n            }\n          case \"TryStatement\":\n            EvaluateChildren(node, [\"block\", \"handler\", \"finalizer\"], parent);\n            return;\n          case \"VariableDeclaration\":\n            EvaluateChildren(node, [\"declarations\"], parent);\n            return;\n          case \"VariableDeclarator\":\n            EvaluateChildren(node, [\"id\", \"init\"], parent);\n            return;\n          case \"WhileStatement\":\n            EvaluateChildren(node, [\"test\", \"body\"], parent);\n            return;\n        }\n      }\n      const silent = (_hooks$beforeVisitUnk = hooks.beforeVisitUnknown) === null || _hooks$beforeVisitUnk === void 0 ? void 0 : _hooks$beforeVisitUnk.call(hooks, node, parent);\n      if (!silent) {\n        // eslint-disable-next-line no-console\n        console.warn(`Unsupported node type \\`${node.type}\\``);\n      }\n    }\n  }\n  function BoundNamesInstantiation(declarations, env) {\n    for (const name of collectBoundNames(declarations)) {\n      env.CreateBinding(name);\n    }\n  }\n  function ResolveBinding(name) {\n    const env = getRunningContext().LexicalEnvironment;\n    return GetIdentifierReference(env, name);\n  }\n  function GetIdentifierReference(env, name) {\n    return !!env && (env.HasBinding(name) || GetIdentifierReference(env.OuterEnv, name));\n  }\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    BoundNamesInstantiation(declarations, env);\n  }\n  function CallFunction(closure, parent) {\n    PrepareOrdinaryCall(closure);\n    FunctionDeclarationInstantiation(closure, parent);\n    Evaluate(closure.ECMAScriptCode, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: closure.Function,\n      key: \"body\"\n    }).concat(closure.Function.body.type === \"BlockStatement\" ? {\n      node: closure.Function.body,\n      key: \"body\"\n    } : []));\n    analysisContextStack.pop();\n  }\n  function PrepareOrdinaryCall(F) {\n    const calleeContext = new AnalysisContext();\n    const localEnv = new AnalysisEnvironment(F.Environment);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    analysisContextStack.push(calleeContext);\n  }\n  function FunctionDeclarationInstantiation(func, parent) {\n    const calleeContext = getRunningContext();\n    const code = func.ECMAScriptCode;\n    const formals = func.FormalParameters;\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n    const argumentsObjectNeeded = !!externalSourceForDebug && func.ThisMode !== \"LEXICAL\";\n    const env = calleeContext.LexicalEnvironment;\n    BoundNamesInstantiation(formals, env);\n    if (argumentsObjectNeeded) {\n      env.CreateBinding(\"arguments\");\n    }\n    Evaluate(formals, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: func.Function,\n      key: \"params\"\n    }));\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      for (const n of varNames) {\n        env.CreateBinding(n);\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new AnalysisEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      for (const n of varNames) {\n        varEnv.CreateBinding(n);\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    BoundNamesInstantiation(lexDeclarations, lexEnv);\n  }\n  function InstantiateOrdinaryFunctionExpression(functionExpression) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (!functionExpression.id) {\n      return OrdinaryFunctionCreate(functionExpression, scope);\n    }\n    const name = functionExpression.id.name;\n    const funcEnv = new AnalysisEnvironment(scope);\n    funcEnv.CreateBinding(name);\n    return OrdinaryFunctionCreate(functionExpression, funcEnv);\n  }\n  function OrdinaryFunctionCreate(func, scope, lexicalThis) {\n    return {\n      Function: func,\n      FormalParameters: func.params,\n      ECMAScriptCode: func.body.type === \"BlockStatement\" ? func.body.body : func.body,\n      Environment: scope,\n      ThisMode: lexicalThis ? \"LEXICAL\" : \"STRICT\"\n    };\n  }\n  Evaluate(rootAst, withParent ? [] : undefined);\n  return attemptToVisitGlobals;\n}\n//# sourceMappingURL=precook.js.map","export function hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n//# sourceMappingURL=hasOwnProperty.js.map","import { parseAsEstree } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nlet ASTCache = new WeakMap();\nexport function precookFunction(source) {\n  let {\n    typescript,\n    cacheKey,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let func = cacheKey ? ASTCache.get(cacheKey) : undefined;\n  if (!func) {\n    func = parseAsEstree(source, {\n      typescript\n    });\n    if (cacheKey) {\n      ASTCache.set(cacheKey, func);\n    }\n  }\n  const attemptToVisitGlobals = precook(func, restOptions);\n  return {\n    function: func,\n    attemptToVisitGlobals\n  };\n}\nexport function clearFunctionASTCache() {\n  ASTCache = new WeakMap();\n}\n//# sourceMappingURL=precookFunction.js.map","import { parse, parseExpression } from \"@babel/parser\";\nexport function parseAsEstreeExpression(source) {\n  return parseExpression(source, {\n    plugins: [\"estree\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }]],\n    attachComment: false\n  });\n}\nexport function parseAsEstree(source) {\n  let {\n    typescript\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const file = parse(source, {\n    plugins: [\"estree\", typescript && \"typescript\"].filter(Boolean),\n    strictMode: true,\n    attachComment: false\n  });\n  const body = file.program.body;\n  const jsNodes = typescript ? [] : body;\n  if (typescript) {\n    for (const node of body) {\n      if (node.type.startsWith(\"TS\")) {\n        if (/Enum|Import|Export/.test(node.type)) {\n          throw new SyntaxError(`Unsupported TypeScript syntax: ${node.type}`);\n        }\n      } else {\n        jsNodes.push(node);\n      }\n    }\n  }\n  if (jsNodes.length === 0) {\n    throw new SyntaxError(\"Function declaration not found\");\n  }\n  if (jsNodes.length > 1 || jsNodes[0].type !== \"FunctionDeclaration\") {\n    throw new SyntaxError(`Expect a single function declaration at top level, but received: ${jsNodes.map(node => `\"${node.type}\"`).join(\", \")}`);\n  }\n  return jsNodes[0];\n}\n//# sourceMappingURL=parse.js.map","import { parseAsEstreeExpression } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nconst ASTCache = new Map();\n// `raw` should always be asserted by `isEvaluable`.\nexport function preevaluate(raw) {\n  let {\n    cache,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const fixes = [];\n  const source = raw.replace(/^\\s*<%[~=]?\\s|\\s%>\\s*$/g, m => {\n    fixes.push(m);\n    return \"\";\n  });\n  let expression = cache ? ASTCache.get(source) : undefined;\n  if (!expression) {\n    expression = parseAsEstreeExpression(source);\n    if (cache) {\n      ASTCache.set(source, expression);\n    }\n  }\n  const attemptToVisitGlobals = precook(expression, {\n    ...restOptions,\n    expressionOnly: true\n  });\n  return {\n    expression,\n    attemptToVisitGlobals,\n    source,\n    prefix: fixes[0],\n    suffix: fixes[1]\n  };\n}\nexport function isEvaluable(raw) {\n  return /^\\s*<%[~=]?\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function shouldAllowRecursiveEvaluations(raw) {\n  return /^\\s*<%~\\s/.test(raw);\n}\nexport function isTrackAll(raw) {\n  return /^\\s*<%=\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function clearExpressionASTCache() {\n  ASTCache.clear();\n}\n//# sourceMappingURL=preevaluate.js.map"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","toPropertyKey","t","i","r","e","Symbol","toPrimitive","call","TypeError","String","_typeof","o","iterator","constructor","prototype","Mode","SourceNode","for","FormalParameters","ECMAScriptCode","Environment","IsConstructor","ThisMode","DebuggerCall","DebuggerScope","DebuggerNode","DebuggerReturn","ExecutionContext","this","BindingStatus","EnvironmentRecord","outer","Map","undefined","OuterEnv","HasBinding","name","bindingMap","has","CreateMutableBinding","deletable","set","mutable","NormalCompletion","CreateImmutableBinding","strict","InitializeBinding","binding","get","assign","initialized","SetMutableBinding","_strict","ReferenceError","GetBindingValue","HasThisBinding","DeclarativeEnvironment","FunctionEnvironment","F","super","LEXICAL","ThisBindingStatus","UNINITIALIZED","BindThisValue","INITIALIZED","Error","ThisValue","GetThisBinding","ReferenceRecord","base","referenceName","Base","ReferenceName","Strict","CompletionRecord","type","Type","Value","Empty","collectBoundNames","root","names","Set","collect","node","Array","isArray","n","add","declarations","id","elements","left","properties","argument","from","containsExpression","some","computed","collectScopedDeclarations","options","nextOptions","var","Number","topLevel","push","kind","consequent","body","alternate","init","cases","block","handler","finalizer","IsPropertyReference","V","InitializeReferencedBinding","W","CopyDataProperties","target","source","excludedItems","keys","getOwnPropertyNames","concat","getOwnPropertySymbols","nextKey","desc","getOwnPropertyDescriptor","ForDeclarationBindingInstantiation","forDeclaration","env","isConst","LoopContinues","completion","UpdateEmpty","GetValue","ToPropertyKey","arg","GetV","P","PutValue","CreateListIteratorRecord","args","cooked","RequireObjectCoercible","GetIdentifierReference","ApplyStringOrNumericBinaryOperator","leftValue","operator","rightValue","SyntaxError","reservedObjects","WeakSet","Function","self","window","global","getGlobal","allowedConstructors","URLSearchParams","WeakMap","RegExp","globalExecutionContextStack","__dev_only_clearGlobalExecutionContextStack","length","__dev_only_getGlobalExecutionContextStack","cook","rootAst","codeSource","_hooks$beforeEvaluate4","rules","debug","externalSourceForDebug","globalVariables","ArrayConstructor","hooks","arguments","expressionOnly","doSanitize","sanitize","rootEnv","rootContext","VariableEnvironment","LexicalEnvironment","executionContextStack","entries","TemplateMap","currentNode","Evaluate","optionalChainRef","forceYield","_hooks$beforeEvaluate","_hooks$beforeBranch2","beforeEvaluate","endsWith","expression","array","element","spreadValues","ThrowIfFunctionIsInvalid","InstantiateArrowFunctionExpression","rightRef","right","funcName","substring","start","end","thisValue","ref","callee","func","optional","skipped","EvaluateCall","test","ResolveBinding","regex","raw","flags","includes","pattern","baseValue","object","result","propertyKey","EvaluatePropertyAccessWithExpressionKey","property","identifier","propertyNameString","EvaluatePropertyAccessWithIdentifierKey","constructExpr","argList","ArgumentListEvaluation","constructorName","Date","isAllowedConstructor","EvaluateNew","prop","propName","EvaluateComputedPropertyName","propValue","method","SetFunctionName","expr","expressions","chunks","quasis","index","val","join","tagRef","tag","tagFunc","quasi","ApplyUnaryOperator","lref","rval","IsAnonymousFunctionDefinition","NamedEvaluation","DestructuringAssignmentEvaluation","lval","substr","ApplyStringOrNumericAssignment","oldEnv","getRunningContext","blockEnv","BlockDeclarationInstantiation","blockValue","EvaluateStatementList","EvaluateBreakableStatement","stmtResult","DoWhileLoopEvaluation","lhs","lhsKind","uninitializedBoundNames","iterationKind","keyResult","runningContext","newEnv","exprRef","exprValue","EnumerateObjectProperties","ForInOfHeadEvaluation","stmt","iteratorRecord","destructuring","done","nextValue","next","lhsRef","iterationEnv","lhsName","BindingInitialization","status","return","innerResult","ForInOfBodyEvaluation","ForInOfLoopEvaluation","_node$init","ForBodyEvaluation","update","loopEnv","boundNames","dn","perIterationLets","bodyResult","ForLoopEvaluation","InstantiateOrdinaryFunctionExpression","_hooks$beforeBranch","beforeBranch","v","GetThisEnvironment","oldValue","newValue","prefix","switchValue","discriminant","R","input","defaultCaseIndex","findIndex","switchCase","hasDefaultCase","A","slice","found","C","CaseClauseIsSelected","foundInB","B","CaseBlockEvaluation","error","_hooks$beforeEvaluate2","thrownValue","param","catchEnv","argName","CatchClauseEvaluation","declarator","bindingId","WhileLoopEvaluation","increment","perIterationBindings","CreatePerIterationEnvironment","lastIterationEnv","thisIterationEnv","bn","lastValue","excludedNames","valueTarget","KeyedDestructuringAssignmentEvaluation","RestDestructuringAssignmentEvaluation","PropertyDestructuringAssignmentEvaluation","assignmentTarget","isObjectOrArray","IteratorDestructuringAssignmentEvaluation","propertyName","rhsValue","restProperty","code","d","IsConstantDeclaration","fn","fo","InstantiateFunctionObject","debuggerCall","apply","templateLiteral","memo","rawObj","map","template","freeze","GetTemplateObject","CallFunction","closure","thisArgument","_hooks$beforeCall","beforeCall","calleeContext","localEnv","OrdinaryCallBindThis","PrepareForOrdinaryCall","formals","parameterNames","hasParameterExpressions","varDeclarations","varNames","functionNames","functionsToInitialize","unshift","noVar","argumentsObjectNeeded","paramName","parameterBindings","ao","argumentObject","values","ThrowTypeError","CreateUnmappedArgumentsObject","varEnv","IteratorBindingInitialization","instantiatedVarNames","initialValue","lexEnv","lexDeclarations","f","FunctionDeclarationInstantiation","EvaluateFunctionBody","OrdinaryCallEvaluateBody","pop","statements","s","_hooks$beforeEvaluate3","scope","OrdinaryFunctionCreate","functionExpression","funcEnv","arrowFunction","sourceNode","isConstructor","lexicalThis","unwind","defineProperties","params","STRICT","len","count","ExpectedArgumentCount","environment","InitializeBoundName","RestBindingInitialization","KeyedBindingInitialization","PropertyBindingInitialization","restObj","bindingElement","async","generator","AnalysisContext","AnalysisEnvironment","bindingSet","CreateBinding","precook","visitors","withParent","attemptToVisitGlobals","analysisContextStack","EvaluateChildren","parent","forEach","_hooks$beforeVisit","_hooks$beforeVisitUnk","beforeVisit","hasOwnProperty","visit","_hooks$beforeVisitGlo","beforeVisitGlobal","BoundNamesInstantiation","lexicalBinding","beforeVisitUnknown","console","warn","PrepareOrdinaryCall","ASTCache","precookFunction","typescript","cacheKey","restOptions","parse","plugins","filter","Boolean","strictMode","attachComment","program","jsNodes","startsWith","parseAsEstree","function","clearFunctionASTCache","preevaluate","cache","fixes","replace","m","parseExpression","proposal","parseAsEstreeExpression","suffix","isEvaluable","shouldAllowRecursiveEvaluations","isTrackAll","clearExpressionASTCache","clear"],"sourceRoot":""}